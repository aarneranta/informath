sameF_upto : __ : Nat -> A : Set -> relation (prod Set Set Nat (__1 : Nat => A)) .
sameF_p : __ : Nat -> __1 : (__1 : Nat -> bool) -> A : Set -> relation (prod Set Set Nat (__2 : Nat => A)) .
sameF_upto_le : A : Set -> f : (__ : Nat -> A) -> g : (__ : Nat -> A) -> n : Nat -> m : Nat -> __ : Leq n m -> __1 : sameF_upto m A f g -> sameF_upto n A f g .
sameF_p_le : A : Set -> p : (__ : Nat -> bool) -> f : (__ : Nat -> A) -> g : (__ : Nat -> A) -> n : Nat -> m : Nat -> __ : Leq n m -> __1 : sameF_p m p A f g -> sameF_p n p A f g .
prodF : A : Set -> B : Set -> _f : (__ : Nat -> A) -> _g : (__ : Nat -> B) -> _m : Nat -> _x : Nat -> Prod A B .
bigop : __ : Nat -> __1 : (__1 : Nat -> bool) -> H : Set -> __2 : H -> __3 : (__3 : H -> __4 : H -> H) -> __4 : (__4 : Nat -> H) -> H .
bigop_body : __ : Nat -> __1 : (__1 : Nat -> bool) -> H : Set -> __2 : H -> __3 : (__3 : H -> __4 : H -> H) -> __4 : (__4 : Nat -> H) -> H .
bigop_Strue : k : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : (__ : B -> __1 : B -> B) -> f : (__ : Nat -> B) -> __ : Eq (p k) true -> Eq (bigop (plus k (nd 1)) (i : Nat => p i) B nil op (i : Nat => f i)) (op (f k) (bigop k (i : Nat => p i) B nil op (i : Nat => f i))) .
bigop_Sfalse : k : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : (__ : B -> __1 : B -> B) -> f : (__ : Nat -> B) -> __ : Eq (p k) false -> Eq (bigop (plus k (nd 1)) (i : Nat => p i) B nil op (i : Nat => f i)) (bigop k (i : Nat => p i) B nil op (i : Nat => f i)) .
same_bigop : k : Nat -> p1 : (__ : Nat -> bool) -> p2 : (__ : Nat -> bool) -> B : Set -> nil : B -> op : (__ : B -> __1 : B -> B) -> f : (__ : Nat -> B) -> g : (__ : Nat -> B) -> __ : sameF_upto k bool p1 p2 -> __1 : sameF_p k p1 B f g -> Eq (bigop k (i : Nat => p1 i) B nil op (i : Nat => f i)) (bigop k (i : Nat => p2 i) B nil op (i : Nat => g i)) .
pad_bigop : k : Nat -> n : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : (__ : B -> __1 : B -> B) -> f : (__ : Nat -> B) -> __ : Leq n k -> Eq (bigop n (i : Nat => p i) B nil op (i : Nat => f i)) (bigop k (i : Nat => match_bool Set (_0 : bool => bool) false (p i) (leb n i)) B nil op (i : Nat => f i)) .
let_clause_1047 : k : Nat -> n : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : (__ : B -> __1 : B -> B) -> f : (__ : Nat -> B) -> lenk : Leq n k -> j : Nat -> leup : Leq n j -> Hind : (__ : (i : Nat -> __ : Leq n i -> __1 : Lt i j -> Eq (p i) false) -> Eq (bigop n (i : Nat => p i) B nil op (i : Nat => f i)) (bigop j (i : Nat => p i) B nil op (i : Nat => f i))) -> Hfalse : (i : Nat -> __ : Leq n i -> __1 : Lt i (plus j (nd 1)) -> Eq (p i) false) -> x2571 : Nat -> x2572 : Nat -> Eq x2571 (plus (times x2572 (div x2571 x2572)) (mod x2571 x2572)) .
pad_bigop1 : k : Nat -> n : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : (__ : B -> __1 : B -> B) -> f : (__ : Nat -> B) -> __ : Leq n k -> __1 : (i : Nat -> __1 : Leq n i -> __2 : Lt i k -> Eq (p i) false) -> Eq (bigop n (i : Nat => p i) B nil op (i : Nat => f i)) (bigop k (i : Nat => p i) B nil op (i : Nat => f i)) .
bigop_false : n : Nat -> B : Set -> nil : B -> op : (__ : B -> __1 : B -> B) -> f : (__ : Nat -> B) -> Eq (bigop n (i : Nat => false) B nil op (i : Nat => f i)) nil .
Aop : A : Set -> _nil : A -> Set .
mk_Aop : A : Set -> nil : A -> op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op nil a) a) -> _nilr : (a : A -> Eq (op a nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Aop A nil .
match_Aop : A : Set -> _nil : A -> return_sort : Sort -> return_type : (z : Aop A _nil -> return_sort) -> case_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> return_type (mk_Aop A _nil op _nill _nilr _assoc)) -> z : Aop A _nil -> return_type z .
filter_Aop : A : Set -> _nil : A -> return_sort : Sort -> return_type : (z : Aop A _nil -> return_sort) -> return : (z : Aop A _nil -> return_type z) -> z : Aop A _nil -> return_type z .
Aop_ind : A : Set -> _nil : A -> Q_ : (_x_861 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_861 : Aop A _nil -> Q_ x_861 .
Aop_ind_body : A : Set -> _nil : A -> Q_ : (_x_861 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_861 : Aop A _nil -> Q_ x_861 .
Aop_rect_Type4 : A : Set -> _nil : A -> Q_ : (_x_863 : Aop A _nil -> Type4) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_863 : Aop A _nil -> Q_ x_863 .
Aop_rect_Type4_body : A : Set -> _nil : A -> Q_ : (_x_863 : Aop A _nil -> Type4) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_863 : Aop A _nil -> Q_ x_863 .
Aop_rect_Type5 : A : Set -> _nil : A -> Q_ : (_x_865 : Aop A _nil -> Type5) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_865 : Aop A _nil -> Q_ x_865 .
Aop_rect_Type5_body : A : Set -> _nil : A -> Q_ : (_x_865 : Aop A _nil -> Type5) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_865 : Aop A _nil -> Q_ x_865 .
Aop_rect_Type3 : A : Set -> _nil : A -> Q_ : (_x_867 : Aop A _nil -> Type3) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_867 : Aop A _nil -> Q_ x_867 .
Aop_rect_Type3_body : A : Set -> _nil : A -> Q_ : (_x_867 : Aop A _nil -> Type3) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_867 : Aop A _nil -> Q_ x_867 .
Aop_rect_Type2 : A : Set -> _nil : A -> Q_ : (_x_869 : Aop A _nil -> Type2) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_869 : Aop A _nil -> Q_ x_869 .
Aop_rect_Type2_body : A : Set -> _nil : A -> Q_ : (_x_869 : Aop A _nil -> Type2) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_869 : Aop A _nil -> Q_ x_869 .
Aop_rect_Type1 : A : Set -> _nil : A -> Q_ : (_x_871 : Aop A _nil -> Type1) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_871 : Aop A _nil -> Q_ x_871 .
Aop_rect_Type1_body : A : Set -> _nil : A -> Q_ : (_x_871 : Aop A _nil -> Type1) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_871 : Aop A _nil -> Q_ x_871 .
Aop_rect_Type0 : A : Set -> _nil : A -> Q_ : (_x_873 : Aop A _nil -> Set) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_873 : Aop A _nil -> Q_ x_873 .
Aop_rect_Type0_body : A : Set -> _nil : A -> Q_ : (_x_873 : Aop A _nil -> Set) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_873 : Aop A _nil -> Q_ x_873 .
Aop_rect_CProp4 : A : Set -> _nil : A -> Q_ : (_x_875 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_875 : Aop A _nil -> Q_ x_875 .
Aop_rect_CProp4_body : A : Set -> _nil : A -> Q_ : (_x_875 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_875 : Aop A _nil -> Q_ x_875 .
Aop_rect_CProp5 : A : Set -> _nil : A -> Q_ : (_x_877 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_877 : Aop A _nil -> Q_ x_877 .
Aop_rect_CProp5_body : A : Set -> _nil : A -> Q_ : (_x_877 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_877 : Aop A _nil -> Q_ x_877 .
Aop_rect_CProp3 : A : Set -> _nil : A -> Q_ : (_x_879 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_879 : Aop A _nil -> Q_ x_879 .
Aop_rect_CProp3_body : A : Set -> _nil : A -> Q_ : (_x_879 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_879 : Aop A _nil -> Q_ x_879 .
Aop_rect_CProp2 : A : Set -> _nil : A -> Q_ : (_x_881 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_881 : Aop A _nil -> Q_ x_881 .
Aop_rect_CProp2_body : A : Set -> _nil : A -> Q_ : (_x_881 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_881 : Aop A _nil -> Q_ x_881 .
Aop_rect_CProp1 : A : Set -> _nil : A -> Q_ : (_x_883 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_883 : Aop A _nil -> Q_ x_883 .
Aop_rect_CProp1_body : A : Set -> _nil : A -> Q_ : (_x_883 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_883 : Aop A _nil -> Q_ x_883 .
Aop_rect_CProp0 : A : Set -> _nil : A -> Q_ : (_x_885 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_885 : Aop A _nil -> Q_ x_885 .
Aop_rect_CProp0_body : A : Set -> _nil : A -> Q_ : (_x_885 : Aop A _nil -> Prop) -> _H_mk_Aop : (op : (__ : A -> __1 : A -> A) -> _nill : (a : A -> Eq (op _nil a) a) -> _nilr : (a : A -> Eq (op a _nil) a) -> _assoc : (a : A -> b : A -> c : A -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> x_885 : Aop A _nil -> Q_ x_885 .
op : A : Set -> nil : A -> _xxx : Aop A nil -> _x_887 : A -> _x_888 : A -> A .
op_body : A : Set -> nil : A -> _xxx : Aop A nil -> _x_887 : A -> _x_888 : A -> A .
nill : A : Set -> nil : A -> xxx : Aop A nil -> a : A -> Eq (op A nil xxx nil a) a .
nill_body : A : Set -> nil : A -> xxx : Aop A nil -> a : A -> Eq (op A nil xxx nil a) a .
nilr : A : Set -> nil : A -> xxx : Aop A nil -> a : A -> Eq (op A nil xxx a nil) a .
nilr_body : A : Set -> nil : A -> xxx : Aop A nil -> a : A -> Eq (op A nil xxx a nil) a .
assoc : A : Set -> nil : A -> xxx : Aop A nil -> a : A -> b : A -> c : A -> Eq (op A nil xxx a (op A nil xxx b c)) (op A nil xxx (op A nil xxx a b) c) .
assoc_body : A : Set -> nil : A -> xxx : Aop A nil -> a : A -> b : A -> c : A -> Eq (op A nil xxx a (op A nil xxx b c)) (op A nil xxx (op A nil xxx a b) c) .
Aop_inv_ind : x1 : Set -> x2 : x1 -> Hterm : Aop x1 x2 -> P : (_z1500 : Aop x1 x2 -> Prop) -> _H1 : (op : (__ : x1 -> __1 : x1 -> x1) -> _nill : (a : x1 -> Eq (op x2 a) a) -> _nilr : (a : x1 -> Eq (op a x2) a) -> _assoc : (a : x1 -> b : x1 -> c : x1 -> Eq (op a (op b c)) (op (op a b) c)) -> _z1501 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm .
Aop_inv_rect_Type4 : x1 : Set -> x2 : x1 -> Hterm : Aop x1 x2 -> P : (_z1506 : Aop x1 x2 -> Type4) -> _H1 : (op : (__ : x1 -> __1 : x1 -> x1) -> _nill : (a : x1 -> Eq (op x2 a) a) -> _nilr : (a : x1 -> Eq (op a x2) a) -> _assoc : (a : x1 -> b : x1 -> c : x1 -> Eq (op a (op b c)) (op (op a b) c)) -> _z1507 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm .
Aop_inv_rect_Type3 : x1 : Set -> x2 : x1 -> Hterm : Aop x1 x2 -> P : (_z1512 : Aop x1 x2 -> Type3) -> _H1 : (op : (__ : x1 -> __1 : x1 -> x1) -> _nill : (a : x1 -> Eq (op x2 a) a) -> _nilr : (a : x1 -> Eq (op a x2) a) -> _assoc : (a : x1 -> b : x1 -> c : x1 -> Eq (op a (op b c)) (op (op a b) c)) -> _z1513 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm .
Aop_inv_rect_Type2 : x1 : Set -> x2 : x1 -> Hterm : Aop x1 x2 -> P : (_z1518 : Aop x1 x2 -> Type2) -> _H1 : (op : (__ : x1 -> __1 : x1 -> x1) -> _nill : (a : x1 -> Eq (op x2 a) a) -> _nilr : (a : x1 -> Eq (op a x2) a) -> _assoc : (a : x1 -> b : x1 -> c : x1 -> Eq (op a (op b c)) (op (op a b) c)) -> _z1519 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm .
Aop_inv_rect_Type1 : x1 : Set -> x2 : x1 -> Hterm : Aop x1 x2 -> P : (_z1524 : Aop x1 x2 -> Type1) -> _H1 : (op : (__ : x1 -> __1 : x1 -> x1) -> _nill : (a : x1 -> Eq (op x2 a) a) -> _nilr : (a : x1 -> Eq (op a x2) a) -> _assoc : (a : x1 -> b : x1 -> c : x1 -> Eq (op a (op b c)) (op (op a b) c)) -> _z1525 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm .
Aop_inv_rect_Type0 : x1 : Set -> x2 : x1 -> Hterm : Aop x1 x2 -> P : (_z1530 : Aop x1 x2 -> Set) -> _H1 : (op : (__ : x1 -> __1 : x1 -> x1) -> _nill : (a : x1 -> Eq (op x2 a) a) -> _nilr : (a : x1 -> Eq (op a x2) a) -> _assoc : (a : x1 -> b : x1 -> c : x1 -> Eq (op a (op b c)) (op (op a b) c)) -> _z1531 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm .
Aop_inv_rect_CProp4 : x1 : Set -> x2 : x1 -> Hterm : Aop x1 x2 -> P : (_z1536 : Aop x1 x2 -> Prop) -> _H1 : (op : (__ : x1 -> __1 : x1 -> x1) -> _nill : (a : x1 -> Eq (op x2 a) a) -> _nilr : (a : x1 -> Eq (op a x2) a) -> _assoc : (a : x1 -> b : x1 -> c : x1 -> Eq (op a (op b c)) (op (op a b) c)) -> _z1537 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm .
Aop_inv_rect_CProp3 : x1 : Set -> x2 : x1 -> Hterm : Aop x1 x2 -> P : (_z1542 : Aop x1 x2 -> Prop) -> _H1 : (op : (__ : x1 -> __1 : x1 -> x1) -> _nill : (a : x1 -> Eq (op x2 a) a) -> _nilr : (a : x1 -> Eq (op a x2) a) -> _assoc : (a : x1 -> b : x1 -> c : x1 -> Eq (op a (op b c)) (op (op a b) c)) -> _z1543 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm .
Aop_inv_rect_CProp2 : x1 : Set -> x2 : x1 -> Hterm : Aop x1 x2 -> P : (_z1548 : Aop x1 x2 -> Prop) -> _H1 : (op : (__ : x1 -> __1 : x1 -> x1) -> _nill : (a : x1 -> Eq (op x2 a) a) -> _nilr : (a : x1 -> Eq (op a x2) a) -> _assoc : (a : x1 -> b : x1 -> c : x1 -> Eq (op a (op b c)) (op (op a b) c)) -> _z1549 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm .
Aop_inv_rect_CProp1 : x1 : Set -> x2 : x1 -> Hterm : Aop x1 x2 -> P : (_z1554 : Aop x1 x2 -> Prop) -> _H1 : (op : (__ : x1 -> __1 : x1 -> x1) -> _nill : (a : x1 -> Eq (op x2 a) a) -> _nilr : (a : x1 -> Eq (op a x2) a) -> _assoc : (a : x1 -> b : x1 -> c : x1 -> Eq (op a (op b c)) (op (op a b) c)) -> _z1555 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm .
Aop_inv_rect_CProp0 : x1 : Set -> x2 : x1 -> Hterm : Aop x1 x2 -> P : (_z1560 : Aop x1 x2 -> Prop) -> _H1 : (op : (__ : x1 -> __1 : x1 -> x1) -> _nill : (a : x1 -> Eq (op x2 a) a) -> _nilr : (a : x1 -> Eq (op a x2) a) -> _assoc : (a : x1 -> b : x1 -> c : x1 -> Eq (op a (op b c)) (op (op a b) c)) -> _z1561 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm .
Aop_discr : a1 : Set -> a2 : a1 -> x : Aop a1 a2 -> y : Aop a1 a2 -> _e : Eq x y -> match_Aop a1 a2 (plus Type2 (nd 1)) (__ : Aop a1 a2 => univ Type2) (t0 : (__ : a1 -> __1 : a1 -> a1) => t1 : (a : a1 -> Eq (t0 a2 a) a) => t2 : (a : a1 -> Eq (t0 a a2) a) => t3 : (a : a1 -> b : a1 -> c : a1 -> Eq (t0 a (t0 b c)) (t0 (t0 a b) c)) => match_Aop a1 a2 (plus Type2 (nd 1)) (__ : Aop a1 a2 => univ Type2) (u0 : (__ : a1 -> __1 : a1 -> a1) => u1 : (a : a1 -> Eq (u0 a2 a) a) => u2 : (a : a1 -> Eq (u0 a a2) a) => u3 : (a : a1 -> b : a1 -> c : a1 -> Eq (u0 a (u0 b c)) (u0 (u0 a b) c)) => prod (plus Type1 (nd 1)) Type1 (univ Type1) (P : Type1 => prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0) u0) (e0 : Eq (R0 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0) u0 => prod Prop Type1 (Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => prod Set Prop a1 (a : a1 => Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1) (e1 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => prod Set Prop a1 (a : a1 => Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1 => prod Prop Type1 (Eq (R2 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x0 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x0 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p0 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 __) t1 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2) (e2 : Eq (R2 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x0 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x0 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p0 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 __) t1 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2 => prod Prop Type1 (Eq (R3 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x0 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x0 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p0 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 __) t1 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 __) t2 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => p1 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => x2 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__ : a1 -> __1 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 p1 => __ : Eq (R2 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x01 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x01 => (x02 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x01 __) t1 (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (x02 : (__ : a1 -> __1 : a1 -> a1) => p02 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x01 p01 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x02 : (__ : a1 -> __1 : a1 -> a1) => p02 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => (x02 : (__1 : a1 -> __2 : a1 -> a1) => p02 : Eq t0 x02 => x12 : (a : a1 -> Eq (x02 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 => prod Set Prop a1 (a : a1 => Eq (x02 a a2) a)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => x21 : (a : a1 -> Eq (x01 a a2) a) => p2 : Eq (R2 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x02 : (__1 : a1 -> __2 : a1 -> a1) => __1 : Eq t0 x02 => (x00 : (__2 : a1 -> __3 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x02 __1) t1 (x02 : (__1 : a1 -> __2 : a1 -> a1) => p02 : Eq t0 x02 => x12 : (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x02 p02 => __1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 => (x00 : (__2 : a1 -> __3 : a1 -> a1) => p00 : Eq t0 x00 => x10 : (a : a1 -> Eq (x00 a2 a) a) => p10 : Eq (R1 (prod Set Set a1 (__2 : a1 => prod Set Set a1 (__3 : a1 => a1))) t0 (x_19 : (__2 : a1 -> __3 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x011 : (__2 : a1 -> __3 : a1 -> a1) => p011 : Eq t0 x011 => prod Set Prop a1 (a : a1 => Eq (x011 a2 a) a)) x_19 _x_20) t1 x00 p00) x10 => prod Set Prop a1 (a : a1 => Eq (x00 a a2) a)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 => prod Set Prop a1 (a : a1 => prod Set Prop a1 (b : a1 => prod Set Prop a1 (c : a1 => Eq (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3) (_e3 : Eq (R3 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x0 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x0 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p0 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 __) t1 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 __) t2 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => p1 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => x2 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__ : a1 -> __1 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 p1 => __ : Eq (R2 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x01 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x01 => (x02 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x01 __) t1 (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (x02 : (__ : a1 -> __1 : a1 -> a1) => p02 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x01 p01 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x02 : (__ : a1 -> __1 : a1 -> a1) => p02 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => (x02 : (__1 : a1 -> __2 : a1 -> a1) => p02 : Eq t0 x02 => x12 : (a : a1 -> Eq (x02 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 => prod Set Prop a1 (a : a1 => Eq (x02 a a2) a)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => x21 : (a : a1 -> Eq (x01 a a2) a) => p2 : Eq (R2 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x02 : (__1 : a1 -> __2 : a1 -> a1) => __1 : Eq t0 x02 => (x00 : (__2 : a1 -> __3 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x02 __1) t1 (x02 : (__1 : a1 -> __2 : a1 -> a1) => p02 : Eq t0 x02 => x12 : (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x02 p02 => __1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 => (x00 : (__2 : a1 -> __3 : a1 -> a1) => p00 : Eq t0 x00 => x10 : (a : a1 -> Eq (x00 a2 a) a) => p10 : Eq (R1 (prod Set Set a1 (__2 : a1 => prod Set Set a1 (__3 : a1 => a1))) t0 (x_19 : (__2 : a1 -> __3 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x011 : (__2 : a1 -> __3 : a1 -> a1) => p011 : Eq t0 x011 => prod Set Prop a1 (a : a1 => Eq (x011 a2 a) a)) x_19 _x_20) t1 x00 p00) x10 => prod Set Prop a1 (a : a1 => Eq (x00 a a2) a)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 => prod Set Prop a1 (a : a1 => prod Set Prop a1 (b : a1 => prod Set Prop a1 (c : a1 => Eq (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3 => P))))) (_z55 : (e0 : Eq (R0 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0) u0 -> e1 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => prod Set Prop a1 (a : a1 => Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1 -> e2 : Eq (R2 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x0 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x0 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p0 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 __) t1 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2 -> _e3 : Eq (R3 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x0 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x0 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p0 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 __) t1 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 __) t2 (x0 : (__ : a1 -> __1 : a1 -> a1) => p0 : Eq t0 x0 => x1 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x0 p0 => p1 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => prod Set Prop a1 (a : a1 => Eq (x01 a2 a) a)) x_19 _x_20) t1 x0 p0) x1 => x2 : (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__ : a1 -> __1 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x01 a a2) a)) x0 p0 x1 p1 => __ : Eq (R2 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x01 : (__ : a1 -> __1 : a1 -> a1) => __ : Eq t0 x01 => (x02 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x01 __) t1 (x01 : (__ : a1 -> __1 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (x02 : (__ : a1 -> __1 : a1 -> a1) => p02 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x01 p01 => __ : Eq (R1 (prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t0 (x_19 : (__ : a1 -> __1 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x02 : (__ : a1 -> __1 : a1 -> a1) => p02 : Eq t0 x02 => prod Set Prop a1 (a : a1 => Eq (x02 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => (x02 : (__1 : a1 -> __2 : a1 -> a1) => p02 : Eq t0 x02 => x12 : (a : a1 -> Eq (x02 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 => prod Set Prop a1 (a : a1 => Eq (x02 a a2) a)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 => (x01 : (__1 : a1 -> __2 : a1 -> a1) => p01 : Eq t0 x01 => x11 : (a : a1 -> Eq (x01 a2 a) a) => p11 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x01 p01) x11 => x21 : (a : a1 -> Eq (x01 a a2) a) => p2 : Eq (R2 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x02 : (__1 : a1 -> __2 : a1 -> a1) => __1 : Eq t0 x02 => (x00 : (__2 : a1 -> __3 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x02 __1) t1 (x02 : (__1 : a1 -> __2 : a1 -> a1) => p02 : Eq t0 x02 => x12 : (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x02 p02 => __1 : Eq (R1 (prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t0 (x_19 : (__1 : a1 -> __2 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x00 : (__1 : a1 -> __2 : a1 -> a1) => p00 : Eq t0 x00 => prod Set Prop a1 (a : a1 => Eq (x00 a2 a) a)) x_19 _x_20) t1 x02 p02) x12 => (x00 : (__2 : a1 -> __3 : a1 -> a1) => p00 : Eq t0 x00 => x10 : (a : a1 -> Eq (x00 a2 a) a) => p10 : Eq (R1 (prod Set Set a1 (__2 : a1 => prod Set Set a1 (__3 : a1 => a1))) t0 (x_19 : (__2 : a1 -> __3 : a1 -> a1) => _x_20 : Eq t0 x_19 => (x011 : (__2 : a1 -> __3 : a1 -> a1) => p011 : Eq t0 x011 => prod Set Prop a1 (a : a1 => Eq (x011 a2 a) a)) x_19 _x_20) t1 x00 p00) x10 => prod Set Prop a1 (a : a1 => Eq (x00 a a2) a)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 => prod Set Prop a1 (a : a1 => prod Set Prop a1 (b : a1 => prod Set Prop a1 (c : a1 => Eq (x01 a (x01 b c)) (x01 (x01 a b) c))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3 -> P) => P))) y) x .
dpi1__o__op : x0 : Set -> x1 : x0 -> x2 : (__ : Aop x0 x1 -> Set) -> x3 : DPair (Aop x0 x1) x2 -> _x_887 : x0 -> _x_888 : x0 -> x0 .
pad_bigop_nil : k : Nat -> n : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : Aop B nil -> f : (__ : Nat -> B) -> __ : Leq n k -> __1 : (i : Nat -> __1 : Leq n i -> __2 : Lt i k -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (i : Nat => p i) B nil (op B nil op) (i : Nat => f i)) (bigop k (i : Nat => p i) B nil (op B nil op) (i : Nat => f i)) .
bigop_sum : k1 : Nat -> k2 : Nat -> p1 : (__ : Nat -> bool) -> p2 : (__ : Nat -> bool) -> B : Set -> nil : B -> op : Aop B nil -> f : (__ : Nat -> B) -> g : (__ : Nat -> B) -> Eq (op B nil op (bigop k1 (i : Nat => p1 i) B nil (op B nil op) (i : Nat => f i)) (bigop k2 (i : Nat => p2 i) B nil (op B nil op) (i : Nat => g i))) (bigop (plus k1 k2) (i : Nat => match_bool Set (__ : bool => bool) (p1 (minus i k2)) (p2 i) (leb k2 i)) B nil (op B nil op) (i : Nat => match_bool Set (__ : bool => B) (f (minus i k2)) (g i) (leb k2 i))) .
plus_minus1 : a : Nat -> b : Nat -> c : Nat -> __ : Leq c b -> Eq (plus a (minus b c)) (minus (plus a b) c) .
bigop_I : n : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : Aop B nil -> f : (__ : Nat -> B) -> Eq (bigop (minus n 0) (i : Nat => (i0 : Nat => p i0) (plus i 0)) B nil (op B nil op) (i : Nat => (i0 : Nat => f i0) (plus i 0))) (bigop n (i : Nat => p i) B nil (op B nil op) (i : Nat => f i)) .
bigop_I_gen : a : Nat -> b : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : Aop B nil -> f : (__ : Nat -> B) -> __ : Leq a b -> Eq (bigop (minus b a) (i : Nat => (i0 : Nat => p i0) (plus i a)) B nil (op B nil op) (i : Nat => (i0 : Nat => f i0) (plus i a))) (bigop b (i : Nat => andb (leb a i) (p i)) B nil (op B nil op) (i : Nat => f i)) .
bigop_sumI : a : Nat -> b : Nat -> c : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : Aop B nil -> f : (__ : Nat -> B) -> __ : Leq a b -> __1 : Leq b c -> Eq (bigop (minus c a) (i : Nat => (i0 : Nat => p i0) (plus i a)) B nil (op B nil op) (i : Nat => (i0 : Nat => f i0) (plus i a))) (op B nil op (bigop (minus c b) (i : Nat => (i0 : Nat => p i0) (plus i b)) B nil (op B nil op) (i : Nat => (i0 : Nat => f i0) (plus i b))) (bigop (minus b a) (i : Nat => (i0 : Nat => p i0) (plus i a)) B nil (op B nil op) (i : Nat => (i0 : Nat => f i0) (plus i a)))) .
bigop_a : a : Nat -> b : Nat -> B : Set -> nil : B -> op : Aop B nil -> f : (__ : Nat -> B) -> __ : Leq a b -> Eq (bigop (minus (plus b (nd 1)) a) (i : Nat => (i0 : Nat => true) (plus i a)) B nil (op B nil op) (i : Nat => (i0 : Nat => f i0) (plus i a))) (op B nil op (bigop (minus b a) (i : Nat => (i0 : Nat => true) (plus i a)) B nil (op B nil op) (i : Nat => (i0 : Nat => f (succ i0)) (plus i a))) (f a)) .
bigop_0 : n : Nat -> B : Set -> nil : B -> op : Aop B nil -> f : (__ : Nat -> B) -> Eq (bigop (plus n (nd 1)) (i : Nat => true) B nil (op B nil op) (i : Nat => f i)) (op B nil op (bigop n (i : Nat => true) B nil (op B nil op) (i : Nat => f (plus i (nd 1)))) (f 0)) .
bigop_prod : k1 : Nat -> k2 : Nat -> p1 : (__ : Nat -> bool) -> p2 : (__ : Nat -> __1 : Nat -> bool) -> B : Set -> nil : B -> op : Aop B nil -> f : (__ : Nat -> __1 : Nat -> B) -> Eq (bigop k1 (x : Nat => p1 x) B nil (op B nil op) (x : Nat => bigop k2 (i : Nat => p2 x i) B nil (op B nil op) (i : Nat => f x i))) (bigop (times k1 k2) (i : Nat => andb (p1 (div i k2)) (p2 (div i k2) (mod i k2))) B nil (op B nil op) (i : Nat => f (div i k2) (mod i k2))) .
ACop : A : Set -> _nil : A -> Set .
mk_ACop : A : Set -> nil : A -> aop : Aop A nil -> _comm : (a : A -> b : A -> Eq (op A nil aop a b) (op A nil aop b a)) -> ACop A nil .
match_ACop : A : Set -> _nil : A -> return_sort : Sort -> return_type : (z : ACop A _nil -> return_sort) -> case_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> return_type (mk_ACop A _nil aop _comm)) -> z : ACop A _nil -> return_type z .
filter_ACop : A : Set -> _nil : A -> return_sort : Sort -> return_type : (z : ACop A _nil -> return_sort) -> return : (z : ACop A _nil -> return_type z) -> z : ACop A _nil -> return_type z .
ACop_ind : A : Set -> _nil : A -> Q_ : (_x_889 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_889 : ACop A _nil -> Q_ x_889 .
ACop_ind_body : A : Set -> _nil : A -> Q_ : (_x_889 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_889 : ACop A _nil -> Q_ x_889 .
ACop_rect_Type4 : A : Set -> _nil : A -> Q_ : (_x_891 : ACop A _nil -> Type4) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_891 : ACop A _nil -> Q_ x_891 .
ACop_rect_Type4_body : A : Set -> _nil : A -> Q_ : (_x_891 : ACop A _nil -> Type4) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_891 : ACop A _nil -> Q_ x_891 .
ACop_rect_Type5 : A : Set -> _nil : A -> Q_ : (_x_893 : ACop A _nil -> Type5) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_893 : ACop A _nil -> Q_ x_893 .
ACop_rect_Type5_body : A : Set -> _nil : A -> Q_ : (_x_893 : ACop A _nil -> Type5) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_893 : ACop A _nil -> Q_ x_893 .
ACop_rect_Type3 : A : Set -> _nil : A -> Q_ : (_x_895 : ACop A _nil -> Type3) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_895 : ACop A _nil -> Q_ x_895 .
ACop_rect_Type3_body : A : Set -> _nil : A -> Q_ : (_x_895 : ACop A _nil -> Type3) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_895 : ACop A _nil -> Q_ x_895 .
ACop_rect_Type2 : A : Set -> _nil : A -> Q_ : (_x_897 : ACop A _nil -> Type2) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_897 : ACop A _nil -> Q_ x_897 .
ACop_rect_Type2_body : A : Set -> _nil : A -> Q_ : (_x_897 : ACop A _nil -> Type2) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_897 : ACop A _nil -> Q_ x_897 .
ACop_rect_Type1 : A : Set -> _nil : A -> Q_ : (_x_899 : ACop A _nil -> Type1) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_899 : ACop A _nil -> Q_ x_899 .
ACop_rect_Type1_body : A : Set -> _nil : A -> Q_ : (_x_899 : ACop A _nil -> Type1) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_899 : ACop A _nil -> Q_ x_899 .
ACop_rect_Type0 : A : Set -> _nil : A -> Q_ : (_x_901 : ACop A _nil -> Set) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_901 : ACop A _nil -> Q_ x_901 .
ACop_rect_Type0_body : A : Set -> _nil : A -> Q_ : (_x_901 : ACop A _nil -> Set) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_901 : ACop A _nil -> Q_ x_901 .
ACop_rect_CProp4 : A : Set -> _nil : A -> Q_ : (_x_903 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_903 : ACop A _nil -> Q_ x_903 .
ACop_rect_CProp4_body : A : Set -> _nil : A -> Q_ : (_x_903 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_903 : ACop A _nil -> Q_ x_903 .
ACop_rect_CProp5 : A : Set -> _nil : A -> Q_ : (_x_905 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_905 : ACop A _nil -> Q_ x_905 .
ACop_rect_CProp5_body : A : Set -> _nil : A -> Q_ : (_x_905 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_905 : ACop A _nil -> Q_ x_905 .
ACop_rect_CProp3 : A : Set -> _nil : A -> Q_ : (_x_907 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_907 : ACop A _nil -> Q_ x_907 .
ACop_rect_CProp3_body : A : Set -> _nil : A -> Q_ : (_x_907 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_907 : ACop A _nil -> Q_ x_907 .
ACop_rect_CProp2 : A : Set -> _nil : A -> Q_ : (_x_909 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_909 : ACop A _nil -> Q_ x_909 .
ACop_rect_CProp2_body : A : Set -> _nil : A -> Q_ : (_x_909 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_909 : ACop A _nil -> Q_ x_909 .
ACop_rect_CProp1 : A : Set -> _nil : A -> Q_ : (_x_911 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_911 : ACop A _nil -> Q_ x_911 .
ACop_rect_CProp1_body : A : Set -> _nil : A -> Q_ : (_x_911 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_911 : ACop A _nil -> Q_ x_911 .
ACop_rect_CProp0 : A : Set -> _nil : A -> Q_ : (_x_913 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_913 : ACop A _nil -> Q_ x_913 .
ACop_rect_CProp0_body : A : Set -> _nil : A -> Q_ : (_x_913 : ACop A _nil -> Prop) -> _H_mk_ACop : (aop : Aop A _nil -> _comm : (a : A -> b : A -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> x_913 : ACop A _nil -> Q_ x_913 .
aop : A : Set -> nil : A -> _xxx : ACop A nil -> Aop A nil .
aop_body : A : Set -> nil : A -> _xxx : ACop A nil -> Aop A nil .
comm : A : Set -> nil : A -> xxx : ACop A nil -> a : A -> b : A -> Eq (op A nil (aop A nil xxx) a b) (op A nil (aop A nil xxx) b a) .
comm_body : A : Set -> nil : A -> xxx : ACop A nil -> a : A -> b : A -> Eq (op A nil (aop A nil xxx) a b) (op A nil (aop A nil xxx) b a) .
ACop_inv_ind : x1 : Set -> x2 : x1 -> Hterm : ACop x1 x2 -> P : (_z1566 : ACop x1 x2 -> Prop) -> _H1 : (aop : Aop x1 x2 -> _comm : (a : x1 -> b : x1 -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> _z1567 : Eq Hterm (mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm .
ACop_inv_rect_Type4 : x1 : Set -> x2 : x1 -> Hterm : ACop x1 x2 -> P : (_z1572 : ACop x1 x2 -> Type4) -> _H1 : (aop : Aop x1 x2 -> _comm : (a : x1 -> b : x1 -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> _z1573 : Eq Hterm (mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm .
ACop_inv_rect_Type3 : x1 : Set -> x2 : x1 -> Hterm : ACop x1 x2 -> P : (_z1578 : ACop x1 x2 -> Type3) -> _H1 : (aop : Aop x1 x2 -> _comm : (a : x1 -> b : x1 -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> _z1579 : Eq Hterm (mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm .
ACop_inv_rect_Type2 : x1 : Set -> x2 : x1 -> Hterm : ACop x1 x2 -> P : (_z1584 : ACop x1 x2 -> Type2) -> _H1 : (aop : Aop x1 x2 -> _comm : (a : x1 -> b : x1 -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> _z1585 : Eq Hterm (mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm .
ACop_inv_rect_Type1 : x1 : Set -> x2 : x1 -> Hterm : ACop x1 x2 -> P : (_z1590 : ACop x1 x2 -> Type1) -> _H1 : (aop : Aop x1 x2 -> _comm : (a : x1 -> b : x1 -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> _z1591 : Eq Hterm (mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm .
ACop_inv_rect_Type0 : x1 : Set -> x2 : x1 -> Hterm : ACop x1 x2 -> P : (_z1596 : ACop x1 x2 -> Set) -> _H1 : (aop : Aop x1 x2 -> _comm : (a : x1 -> b : x1 -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> _z1597 : Eq Hterm (mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm .
ACop_inv_rect_CProp4 : x1 : Set -> x2 : x1 -> Hterm : ACop x1 x2 -> P : (_z1602 : ACop x1 x2 -> Prop) -> _H1 : (aop : Aop x1 x2 -> _comm : (a : x1 -> b : x1 -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> _z1603 : Eq Hterm (mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm .
ACop_inv_rect_CProp3 : x1 : Set -> x2 : x1 -> Hterm : ACop x1 x2 -> P : (_z1608 : ACop x1 x2 -> Prop) -> _H1 : (aop : Aop x1 x2 -> _comm : (a : x1 -> b : x1 -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> _z1609 : Eq Hterm (mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm .
ACop_inv_rect_CProp2 : x1 : Set -> x2 : x1 -> Hterm : ACop x1 x2 -> P : (_z1614 : ACop x1 x2 -> Prop) -> _H1 : (aop : Aop x1 x2 -> _comm : (a : x1 -> b : x1 -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> _z1615 : Eq Hterm (mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm .
ACop_inv_rect_CProp1 : x1 : Set -> x2 : x1 -> Hterm : ACop x1 x2 -> P : (_z1620 : ACop x1 x2 -> Prop) -> _H1 : (aop : Aop x1 x2 -> _comm : (a : x1 -> b : x1 -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> _z1621 : Eq Hterm (mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm .
ACop_inv_rect_CProp0 : x1 : Set -> x2 : x1 -> Hterm : ACop x1 x2 -> P : (_z1626 : ACop x1 x2 -> Prop) -> _H1 : (aop : Aop x1 x2 -> _comm : (a : x1 -> b : x1 -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> _z1627 : Eq Hterm (mk_ACop x1 x2 aop _comm) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm .
ACop_discr : a1 : Set -> a2 : a1 -> x : ACop a1 a2 -> y : ACop a1 a2 -> _e : Eq x y -> match_ACop a1 a2 (plus Type2 (nd 1)) (__ : ACop a1 a2 => univ Type2) (t0 : Aop a1 a2 => t1 : (a : a1 -> b : a1 -> Eq (op a1 a2 t0 a b) (op a1 a2 t0 b a)) => match_ACop a1 a2 (plus Type2 (nd 1)) (__ : ACop a1 a2 => univ Type2) (u0 : Aop a1 a2 => u1 : (a : a1 -> b : a1 -> Eq (op a1 a2 u0 a b) (op a1 a2 u0 b a)) => prod (plus Type1 (nd 1)) Type1 (univ Type1) (P : Type1 => prod Type1 Type1 (prod Prop Type1 (Eq (R0 (Aop a1 a2) t0) u0) (e0 : Eq (R0 (Aop a1 a2) t0) u0 => prod Prop Type1 (Eq (R1 (Aop a1 a2) t0 (x_19 : Aop a1 a2 => _x_20 : Eq t0 x_19 => (x0 : Aop a1 a2 => p0 : Eq t0 x0 => prod Set Prop a1 (a : a1 => prod Set Prop a1 (b : a1 => Eq (op a1 a2 x0 a b) (op a1 a2 x0 b a)))) x_19 _x_20) t1 u0 e0) u1) (_e1 : Eq (R1 (Aop a1 a2) t0 (x_19 : Aop a1 a2 => _x_20 : Eq t0 x_19 => (x0 : Aop a1 a2 => p0 : Eq t0 x0 => prod Set Prop a1 (a : a1 => prod Set Prop a1 (b : a1 => Eq (op a1 a2 x0 a b) (op a1 a2 x0 b a)))) x_19 _x_20) t1 u0 e0) u1 => P))) (_z57 : (e0 : Eq (R0 (Aop a1 a2) t0) u0 -> _e1 : Eq (R1 (Aop a1 a2) t0 (x_19 : Aop a1 a2 => _x_20 : Eq t0 x_19 => (x0 : Aop a1 a2 => p0 : Eq t0 x0 => prod Set Prop a1 (a : a1 => prod Set Prop a1 (b : a1 => Eq (op a1 a2 x0 a b) (op a1 a2 x0 b a)))) x_19 _x_20) t1 u0 e0) u1 -> P) => P))) y) x .
dpi1__o__aop : x0 : Set -> x1 : x0 -> x2 : (__ : ACop x0 x1 -> Set) -> x3 : DPair (ACop x0 x1) x2 -> Aop x0 x1 .
aop__o__op : x0 : Set -> x1 : x0 -> x2 : ACop x0 x1 -> _x_887 : x0 -> _x_888 : x0 -> x0 .
dpi1__o__aop__o__op : x0 : Set -> x1 : x0 -> x2 : (__ : ACop x0 x1 -> Set) -> x3 : DPair (ACop x0 x1) x2 -> _x_887 : x0 -> _x_888 : x0 -> x0 .
bigop_op : k : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : ACop B nil -> f : (__ : Nat -> B) -> g : (__ : Nat -> B) -> Eq (aop__o__op B nil op (bigop k (i : Nat => p i) B nil (aop__o__op B nil op) (i : Nat => f i)) (bigop k (i : Nat => p i) B nil (aop__o__op B nil op) (i : Nat => g i))) (bigop k (i : Nat => p i) B nil (aop__o__op B nil op) (i : Nat => aop__o__op B nil op (f i) (g i))) .
bigop_diff : p : (__ : Nat -> bool) -> B : Set -> nil : B -> op : ACop B nil -> f : (__ : Nat -> B) -> i : Nat -> n : Nat -> __ : Lt i n -> __1 : Eq (p i) true -> Eq (bigop n (x : Nat => p x) B nil (aop__o__op B nil op) (x : Nat => f x)) (aop__o__op B nil op (f i) (bigop n (x : Nat => andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op) (x : Nat => f x))) .
range : _A : Set -> Set .
mk_range : A : Set -> _enum : (__ : Nat -> A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> range A .
match_range : _A : Set -> return_sort : Sort -> return_type : (z : range _A -> return_sort) -> case_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> return_type (mk_range _A _enum _upto _filter)) -> z : range _A -> return_type z .
filter_range : _A : Set -> return_sort : Sort -> return_type : (z : range _A -> return_sort) -> return : (z : range _A -> return_type z) -> z : range _A -> return_type z .
range_ind : _A : Set -> Q_ : (_x_915 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_915 : range _A -> Q_ x_915 .
range_ind_body : _A : Set -> Q_ : (_x_915 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_915 : range _A -> Q_ x_915 .
range_rect_Type4 : _A : Set -> Q_ : (_x_917 : range _A -> Type4) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_917 : range _A -> Q_ x_917 .
range_rect_Type4_body : _A : Set -> Q_ : (_x_917 : range _A -> Type4) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_917 : range _A -> Q_ x_917 .
range_rect_Type5 : _A : Set -> Q_ : (_x_919 : range _A -> Type5) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_919 : range _A -> Q_ x_919 .
range_rect_Type5_body : _A : Set -> Q_ : (_x_919 : range _A -> Type5) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_919 : range _A -> Q_ x_919 .
range_rect_Type3 : _A : Set -> Q_ : (_x_921 : range _A -> Type3) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_921 : range _A -> Q_ x_921 .
range_rect_Type3_body : _A : Set -> Q_ : (_x_921 : range _A -> Type3) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_921 : range _A -> Q_ x_921 .
range_rect_Type2 : _A : Set -> Q_ : (_x_923 : range _A -> Type2) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_923 : range _A -> Q_ x_923 .
range_rect_Type2_body : _A : Set -> Q_ : (_x_923 : range _A -> Type2) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_923 : range _A -> Q_ x_923 .
range_rect_Type1 : _A : Set -> Q_ : (_x_925 : range _A -> Type1) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_925 : range _A -> Q_ x_925 .
range_rect_Type1_body : _A : Set -> Q_ : (_x_925 : range _A -> Type1) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_925 : range _A -> Q_ x_925 .
range_rect_Type0 : _A : Set -> Q_ : (_x_927 : range _A -> Set) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_927 : range _A -> Q_ x_927 .
range_rect_Type0_body : _A : Set -> Q_ : (_x_927 : range _A -> Set) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_927 : range _A -> Q_ x_927 .
range_rect_CProp4 : _A : Set -> Q_ : (_x_929 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_929 : range _A -> Q_ x_929 .
range_rect_CProp4_body : _A : Set -> Q_ : (_x_929 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_929 : range _A -> Q_ x_929 .
range_rect_CProp5 : _A : Set -> Q_ : (_x_931 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_931 : range _A -> Q_ x_931 .
range_rect_CProp5_body : _A : Set -> Q_ : (_x_931 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_931 : range _A -> Q_ x_931 .
range_rect_CProp3 : _A : Set -> Q_ : (_x_933 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_933 : range _A -> Q_ x_933 .
range_rect_CProp3_body : _A : Set -> Q_ : (_x_933 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_933 : range _A -> Q_ x_933 .
range_rect_CProp2 : _A : Set -> Q_ : (_x_935 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_935 : range _A -> Q_ x_935 .
range_rect_CProp2_body : _A : Set -> Q_ : (_x_935 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_935 : range _A -> Q_ x_935 .
range_rect_CProp1 : _A : Set -> Q_ : (_x_937 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_937 : range _A -> Q_ x_937 .
range_rect_CProp1_body : _A : Set -> Q_ : (_x_937 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_937 : range _A -> Q_ x_937 .
range_rect_CProp0 : _A : Set -> Q_ : (_x_939 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_939 : range _A -> Q_ x_939 .
range_rect_CProp0_body : _A : Set -> Q_ : (_x_939 : range _A -> Prop) -> _H_mk_range : (_enum : (__ : Nat -> _A) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> x_939 : range _A -> Q_ x_939 .
enum : A : Set -> _xxx : range A -> _x_942 : Nat -> A .
enum_body : A : Set -> _xxx : range A -> _x_942 : Nat -> A .
upto : A : Set -> _xxx : range A -> Nat .
upto_body : A : Set -> _xxx : range A -> Nat .
filter : A : Set -> _xxx : range A -> _x_941 : Nat -> bool .
filter_body : A : Set -> _xxx : range A -> _x_941 : Nat -> bool .
range_inv_ind : x1 : Set -> Hterm : range x1 -> P : (_z1632 : range x1 -> Prop) -> _H1 : (_enum : (__ : Nat -> x1) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> _z1633 : Eq Hterm (mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm .
range_inv_rect_Type4 : x1 : Set -> Hterm : range x1 -> P : (_z1638 : range x1 -> Type4) -> _H1 : (_enum : (__ : Nat -> x1) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> _z1639 : Eq Hterm (mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm .
range_inv_rect_Type3 : x1 : Set -> Hterm : range x1 -> P : (_z1644 : range x1 -> Type3) -> _H1 : (_enum : (__ : Nat -> x1) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> _z1645 : Eq Hterm (mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm .
range_inv_rect_Type2 : x1 : Set -> Hterm : range x1 -> P : (_z1650 : range x1 -> Type2) -> _H1 : (_enum : (__ : Nat -> x1) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> _z1651 : Eq Hterm (mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm .
range_inv_rect_Type1 : x1 : Set -> Hterm : range x1 -> P : (_z1656 : range x1 -> Type1) -> _H1 : (_enum : (__ : Nat -> x1) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> _z1657 : Eq Hterm (mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm .
range_inv_rect_Type0 : x1 : Set -> Hterm : range x1 -> P : (_z1662 : range x1 -> Set) -> _H1 : (_enum : (__ : Nat -> x1) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> _z1663 : Eq Hterm (mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm .
range_inv_rect_CProp4 : x1 : Set -> Hterm : range x1 -> P : (_z1668 : range x1 -> Prop) -> _H1 : (_enum : (__ : Nat -> x1) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> _z1669 : Eq Hterm (mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm .
range_inv_rect_CProp3 : x1 : Set -> Hterm : range x1 -> P : (_z1674 : range x1 -> Prop) -> _H1 : (_enum : (__ : Nat -> x1) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> _z1675 : Eq Hterm (mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm .
range_inv_rect_CProp2 : x1 : Set -> Hterm : range x1 -> P : (_z1680 : range x1 -> Prop) -> _H1 : (_enum : (__ : Nat -> x1) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> _z1681 : Eq Hterm (mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm .
range_inv_rect_CProp1 : x1 : Set -> Hterm : range x1 -> P : (_z1686 : range x1 -> Prop) -> _H1 : (_enum : (__ : Nat -> x1) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> _z1687 : Eq Hterm (mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm .
range_inv_rect_CProp0 : x1 : Set -> Hterm : range x1 -> P : (_z1692 : range x1 -> Prop) -> _H1 : (_enum : (__ : Nat -> x1) -> _upto : Nat -> _filter : (__ : Nat -> bool) -> _z1693 : Eq Hterm (mk_range x1 _enum _upto _filter) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm .
range_discr : a1 : Set -> x : range a1 -> y : range a1 -> _e : Eq x y -> match_range a1 (plus Type2 (nd 1)) (__ : range a1 => univ Type2) (t0 : (__ : Nat -> a1) => t1 : Nat => t2 : (__ : Nat -> bool) => match_range a1 (plus Type2 (nd 1)) (__ : range a1 => univ Type2) (u0 : (__ : Nat -> a1) => u1 : Nat => u2 : (__ : Nat -> bool) => prod (plus Type1 (nd 1)) Type1 (univ Type1) (P : Type1 => prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set Nat (__ : Nat => a1)) t0) u0) (e0 : Eq (R0 (prod Set Set Nat (__ : Nat => a1)) t0) u0 => prod Prop Type1 (Eq (R1 (prod Set Set Nat (__ : Nat => a1)) t0 (x0 : (__ : Nat -> a1) => p0 : Eq t0 x0 => Nat) t1 u0 e0) u1) (e1 : Eq (R1 (prod Set Set Nat (__ : Nat => a1)) t0 (x0 : (__ : Nat -> a1) => p0 : Eq t0 x0 => Nat) t1 u0 e0) u1 => prod Prop Type1 (Eq (R2 (prod Set Set Nat (__ : Nat => a1)) t0 (x0 : (__ : Nat -> a1) => p0 : Eq t0 x0 => Nat) t1 (x0 : (__ : Nat -> a1) => p0 : Eq t0 x0 => x1 : Nat => p1 : Eq (R1 (prod Set Set Nat (__ : Nat => a1)) t0 (x00 : (__ : Nat -> a1) => p00 : Eq t0 x00 => Nat) t1 x0 p0) x1 => prod Set Set Nat (__ : Nat => bool)) t2 u0 e0 u1 e1) u2) (_e2 : Eq (R2 (prod Set Set Nat (__ : Nat => a1)) t0 (x0 : (__ : Nat -> a1) => p0 : Eq t0 x0 => Nat) t1 (x0 : (__ : Nat -> a1) => p0 : Eq t0 x0 => x1 : Nat => p1 : Eq (R1 (prod Set Set Nat (__ : Nat => a1)) t0 (x00 : (__ : Nat -> a1) => p00 : Eq t0 x00 => Nat) t1 x0 p0) x1 => prod Set Set Nat (__ : Nat => bool)) t2 u0 e0 u1 e1) u2 => P)))) (_z59 : (e0 : Eq (R0 (prod Set Set Nat (__ : Nat => a1)) t0) u0 -> e1 : Eq (R1 (prod Set Set Nat (__ : Nat => a1)) t0 (x0 : (__ : Nat -> a1) => p0 : Eq t0 x0 => Nat) t1 u0 e0) u1 -> _e2 : Eq (R2 (prod Set Set Nat (__ : Nat => a1)) t0 (x0 : (__ : Nat -> a1) => p0 : Eq t0 x0 => Nat) t1 (x0 : (__ : Nat -> a1) => p0 : Eq t0 x0 => x1 : Nat => p1 : Eq (R1 (prod Set Set Nat (__ : Nat => a1)) t0 (x00 : (__ : Nat -> a1) => p00 : Eq t0 x00 => Nat) t1 x0 p0) x1 => prod Set Set Nat (__ : Nat => bool)) t2 u0 e0 u1 e1) u2 -> P) => P))) y) x .
sub_hk : __ : (__ : Nat -> Nat) -> __1 : (__1 : Nat -> Nat) -> A : Set -> relation (range A) .
iso : A : Set -> relation (range A) .
sub_hkO : h : (__ : Nat -> Nat) -> k : (__ : Nat -> Nat) -> A : Set -> I : range A -> J : range A -> __ : Eq (upto A I) 0 -> sub_hk h k A I J .
sub0_to_false : h : (__ : Nat -> Nat) -> k : (__ : Nat -> Nat) -> A : Set -> I : range A -> J : range A -> __ : Eq (upto A I) 0 -> __1 : sub_hk h k A J I -> i : Nat -> __2 : Lt i (upto A J) -> Eq (filter A J i) false .
sub_lt : A : Set -> e : (__ : Nat -> A) -> p : (__ : Nat -> bool) -> n : Nat -> m : Nat -> __ : Leq n m -> sub_hk (x : Nat => x) (x : Nat => x) A (mk_range A e n p) (mk_range A e m p) .
transitive_sub : h1 : (__ : Nat -> Nat) -> k1 : (__ : Nat -> Nat) -> h2 : (__ : Nat -> Nat) -> k2 : (__ : Nat -> Nat) -> A : Set -> I : range A -> J : range A -> K : range A -> __ : sub_hk h1 k1 A I J -> __1 : sub_hk h2 k2 A J K -> sub_hk (x : Nat => h2 (h1 x)) (x : Nat => k1 (k2 x)) A I K .
let_clause_10471 : n1 : Nat -> n2 : Nat -> p1 : (__ : Nat -> bool) -> p2 : (__ : Nat -> bool) -> B : Set -> nil : B -> op : ACop B nil -> f1 : (__ : Nat -> B) -> f2 : (__ : Nat -> B) -> _clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2) -> h : (__ : Nat -> Nat) -> _clearme0 : ex (prod Set Set Nat (__ : Nat => Nat)) (k : (__ : Nat -> Nat) => and (and (prod Set Prop Nat (i : Nat => prod Prop Prop (Lt i n1) (__ : Lt i n1 => prod Prop Prop (Eq (p1 i) true) (__1 : Eq (p1 i) true => Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> k : (__ : Nat -> Nat) -> _clearme1 : and (and (prod Set Prop Nat (i : Nat => prod Prop Prop (Lt i n1) (__ : Lt i n1 => prod Prop Prop (Eq (p1 i) true) (__1 : Eq (p1 i) true => Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)) -> _clearme2 : and (prod Set Prop Nat (i : Nat => prod Prop Prop (Lt i n1) (__ : Lt i n1 => prod Prop Prop (Eq (p1 i) true) (__1 : Eq (p1 i) true => Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> same : (i : Nat -> __ : Lt i n1 -> __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i))) -> i : Nat -> m : Nat -> Hind : (f : (__ : Nat -> bool) -> __ : Leq 0 n1 -> __1 : sub_hk h k B (mk_range B f1 0 p1) (mk_range B f2 m f) -> __2 : sub_hk k h B (mk_range B f2 m f) (mk_range B f1 0 p1) -> Eq (bigop 0 (i0 : Nat => p1 i0) B nil (aop__o__op B nil op) (i0 : Nat => f1 i0)) (bigop m (i0 : Nat => f i0) B nil (aop__o__op B nil op) (i0 : Nat => f2 i0))) -> p20 : (__ : Nat -> bool) -> __ : Leq 0 n1 -> sub1 : sub_hk h k B (mk_range B f1 0 p1) (mk_range B f2 (plus m (nd 1)) p20) -> sub2 : sub_hk k h B (mk_range B f2 (plus m (nd 1)) p20) (mk_range B f1 0 p1) -> x2571 : Nat -> x2572 : Nat -> Eq x2571 (plus (times x2572 (div x2571 x2572)) (mod x2571 x2572)) .
bigop_iso : n1 : Nat -> n2 : Nat -> p1 : (__ : Nat -> bool) -> p2 : (__ : Nat -> bool) -> B : Set -> nil : B -> op : ACop B nil -> f1 : (__ : Nat -> B) -> f2 : (__ : Nat -> B) -> __ : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2) -> Eq (bigop n1 (i : Nat => p1 i) B nil (aop__o__op B nil op) (i : Nat => f1 i)) (bigop n2 (i : Nat => p2 i) B nil (aop__o__op B nil op) (i : Nat => f2 i)) .
bigop_commute : n : Nat -> m : Nat -> p11 : (__ : Nat -> bool) -> p12 : (__ : Nat -> __1 : Nat -> bool) -> p21 : (__ : Nat -> bool) -> p22 : (__ : Nat -> __1 : Nat -> bool) -> B : Set -> nil : B -> op : ACop B nil -> f : (__ : Nat -> __1 : Nat -> B) -> __ : Lt 0 n -> __1 : Lt 0 m -> __2 : (i : Nat -> j : Nat -> __2 : Lt i n -> __3 : Lt j m -> Eq (andb (p11 i) (p12 i j)) (andb (p21 j) (p22 i j))) -> Eq (bigop n (i : Nat => p11 i) B nil (aop__o__op B nil op) (i : Nat => bigop m (j : Nat => p12 i j) B nil (aop__o__op B nil op) (j : Nat => f i j))) (bigop m (j : Nat => p21 j) B nil (aop__o__op B nil op) (j : Nat => bigop n (i : Nat => p22 i j) B nil (aop__o__op B nil op) (i : Nat => f i j))) .
Dop : A : Set -> _nil : A -> Set .
mk_Dop : A : Set -> nil : A -> sum : ACop A nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a nil) nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A nil sum b c)) (aop__o__op A nil sum (prod a b) (prod a c))) -> Dop A nil .
match_Dop : A : Set -> _nil : A -> return_sort : Sort -> return_type : (z : Dop A _nil -> return_sort) -> case_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> return_type (mk_Dop A _nil sum prod _null _distr)) -> z : Dop A _nil -> return_type z .
filter_Dop : A : Set -> _nil : A -> return_sort : Sort -> return_type : (z : Dop A _nil -> return_sort) -> return : (z : Dop A _nil -> return_type z) -> z : Dop A _nil -> return_type z .
Dop_ind : A : Set -> _nil : A -> Q_ : (_x_943 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_943 : Dop A _nil -> Q_ x_943 .
Dop_ind_body : A : Set -> _nil : A -> Q_ : (_x_943 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_943 : Dop A _nil -> Q_ x_943 .
Dop_rect_Type4 : A : Set -> _nil : A -> Q_ : (_x_945 : Dop A _nil -> Type4) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_945 : Dop A _nil -> Q_ x_945 .
Dop_rect_Type4_body : A : Set -> _nil : A -> Q_ : (_x_945 : Dop A _nil -> Type4) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_945 : Dop A _nil -> Q_ x_945 .
Dop_rect_Type5 : A : Set -> _nil : A -> Q_ : (_x_947 : Dop A _nil -> Type5) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_947 : Dop A _nil -> Q_ x_947 .
Dop_rect_Type5_body : A : Set -> _nil : A -> Q_ : (_x_947 : Dop A _nil -> Type5) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_947 : Dop A _nil -> Q_ x_947 .
Dop_rect_Type3 : A : Set -> _nil : A -> Q_ : (_x_949 : Dop A _nil -> Type3) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_949 : Dop A _nil -> Q_ x_949 .
Dop_rect_Type3_body : A : Set -> _nil : A -> Q_ : (_x_949 : Dop A _nil -> Type3) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_949 : Dop A _nil -> Q_ x_949 .
Dop_rect_Type2 : A : Set -> _nil : A -> Q_ : (_x_951 : Dop A _nil -> Type2) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_951 : Dop A _nil -> Q_ x_951 .
Dop_rect_Type2_body : A : Set -> _nil : A -> Q_ : (_x_951 : Dop A _nil -> Type2) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_951 : Dop A _nil -> Q_ x_951 .
Dop_rect_Type1 : A : Set -> _nil : A -> Q_ : (_x_953 : Dop A _nil -> Type1) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_953 : Dop A _nil -> Q_ x_953 .
Dop_rect_Type1_body : A : Set -> _nil : A -> Q_ : (_x_953 : Dop A _nil -> Type1) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_953 : Dop A _nil -> Q_ x_953 .
Dop_rect_Type0 : A : Set -> _nil : A -> Q_ : (_x_955 : Dop A _nil -> Set) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_955 : Dop A _nil -> Q_ x_955 .
Dop_rect_Type0_body : A : Set -> _nil : A -> Q_ : (_x_955 : Dop A _nil -> Set) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_955 : Dop A _nil -> Q_ x_955 .
Dop_rect_CProp4 : A : Set -> _nil : A -> Q_ : (_x_957 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_957 : Dop A _nil -> Q_ x_957 .
Dop_rect_CProp4_body : A : Set -> _nil : A -> Q_ : (_x_957 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_957 : Dop A _nil -> Q_ x_957 .
Dop_rect_CProp5 : A : Set -> _nil : A -> Q_ : (_x_959 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_959 : Dop A _nil -> Q_ x_959 .
Dop_rect_CProp5_body : A : Set -> _nil : A -> Q_ : (_x_959 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_959 : Dop A _nil -> Q_ x_959 .
Dop_rect_CProp3 : A : Set -> _nil : A -> Q_ : (_x_961 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_961 : Dop A _nil -> Q_ x_961 .
Dop_rect_CProp3_body : A : Set -> _nil : A -> Q_ : (_x_961 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_961 : Dop A _nil -> Q_ x_961 .
Dop_rect_CProp2 : A : Set -> _nil : A -> Q_ : (_x_963 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_963 : Dop A _nil -> Q_ x_963 .
Dop_rect_CProp2_body : A : Set -> _nil : A -> Q_ : (_x_963 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_963 : Dop A _nil -> Q_ x_963 .
Dop_rect_CProp1 : A : Set -> _nil : A -> Q_ : (_x_965 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_965 : Dop A _nil -> Q_ x_965 .
Dop_rect_CProp1_body : A : Set -> _nil : A -> Q_ : (_x_965 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_965 : Dop A _nil -> Q_ x_965 .
Dop_rect_CProp0 : A : Set -> _nil : A -> Q_ : (_x_967 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_967 : Dop A _nil -> Q_ x_967 .
Dop_rect_CProp0_body : A : Set -> _nil : A -> Q_ : (_x_967 : Dop A _nil -> Prop) -> _H_mk_Dop : (sum : ACop A _nil -> prod : (__ : A -> __1 : A -> A) -> _null : (a : A -> Eq (prod a _nil) _nil) -> _distr : (a : A -> b : A -> c : A -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> x_967 : Dop A _nil -> Q_ x_967 .
sum : A : Set -> nil : A -> _xxx : Dop A nil -> ACop A nil .
sum_body : A : Set -> nil : A -> _xxx : Dop A nil -> ACop A nil .
prod : A : Set -> nil : A -> _xxx : Dop A nil -> _x_969 : A -> _x_970 : A -> A .
prod_body : A : Set -> nil : A -> _xxx : Dop A nil -> _x_969 : A -> _x_970 : A -> A .
null : A : Set -> nil : A -> xxx : Dop A nil -> a : A -> Eq (prod A nil xxx a nil) nil .
null_body : A : Set -> nil : A -> xxx : Dop A nil -> a : A -> Eq (prod A nil xxx a nil) nil .
distr : A : Set -> nil : A -> xxx : Dop A nil -> a : A -> b : A -> c : A -> Eq (prod A nil xxx a (aop__o__op A nil (sum A nil xxx) b c)) (aop__o__op A nil (sum A nil xxx) (prod A nil xxx a b) (prod A nil xxx a c)) .
distr_body : A : Set -> nil : A -> xxx : Dop A nil -> a : A -> b : A -> c : A -> Eq (prod A nil xxx a (aop__o__op A nil (sum A nil xxx) b c)) (aop__o__op A nil (sum A nil xxx) (prod A nil xxx a b) (prod A nil xxx a c)) .
Dop_inv_ind : x1 : Set -> x2 : x1 -> Hterm : Dop x1 x2 -> P : (_z1698 : Dop x1 x2 -> Prop) -> _H1 : (sum : ACop x1 x2 -> prod : (__ : x1 -> __1 : x1 -> x1) -> _null : (a : x1 -> Eq (prod a x2) x2) -> _distr : (a : x1 -> b : x1 -> c : x1 -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> _z1699 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm .
Dop_inv_rect_Type4 : x1 : Set -> x2 : x1 -> Hterm : Dop x1 x2 -> P : (_z1704 : Dop x1 x2 -> Type4) -> _H1 : (sum : ACop x1 x2 -> prod : (__ : x1 -> __1 : x1 -> x1) -> _null : (a : x1 -> Eq (prod a x2) x2) -> _distr : (a : x1 -> b : x1 -> c : x1 -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> _z1705 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm .
Dop_inv_rect_Type3 : x1 : Set -> x2 : x1 -> Hterm : Dop x1 x2 -> P : (_z1710 : Dop x1 x2 -> Type3) -> _H1 : (sum : ACop x1 x2 -> prod : (__ : x1 -> __1 : x1 -> x1) -> _null : (a : x1 -> Eq (prod a x2) x2) -> _distr : (a : x1 -> b : x1 -> c : x1 -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> _z1711 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm .
Dop_inv_rect_Type2 : x1 : Set -> x2 : x1 -> Hterm : Dop x1 x2 -> P : (_z1716 : Dop x1 x2 -> Type2) -> _H1 : (sum : ACop x1 x2 -> prod : (__ : x1 -> __1 : x1 -> x1) -> _null : (a : x1 -> Eq (prod a x2) x2) -> _distr : (a : x1 -> b : x1 -> c : x1 -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> _z1717 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm .
Dop_inv_rect_Type1 : x1 : Set -> x2 : x1 -> Hterm : Dop x1 x2 -> P : (_z1722 : Dop x1 x2 -> Type1) -> _H1 : (sum : ACop x1 x2 -> prod : (__ : x1 -> __1 : x1 -> x1) -> _null : (a : x1 -> Eq (prod a x2) x2) -> _distr : (a : x1 -> b : x1 -> c : x1 -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> _z1723 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm .
Dop_inv_rect_Type0 : x1 : Set -> x2 : x1 -> Hterm : Dop x1 x2 -> P : (_z1728 : Dop x1 x2 -> Set) -> _H1 : (sum : ACop x1 x2 -> prod : (__ : x1 -> __1 : x1 -> x1) -> _null : (a : x1 -> Eq (prod a x2) x2) -> _distr : (a : x1 -> b : x1 -> c : x1 -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> _z1729 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm .
Dop_inv_rect_CProp4 : x1 : Set -> x2 : x1 -> Hterm : Dop x1 x2 -> P : (_z1734 : Dop x1 x2 -> Prop) -> _H1 : (sum : ACop x1 x2 -> prod : (__ : x1 -> __1 : x1 -> x1) -> _null : (a : x1 -> Eq (prod a x2) x2) -> _distr : (a : x1 -> b : x1 -> c : x1 -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> _z1735 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm .
Dop_inv_rect_CProp3 : x1 : Set -> x2 : x1 -> Hterm : Dop x1 x2 -> P : (_z1740 : Dop x1 x2 -> Prop) -> _H1 : (sum : ACop x1 x2 -> prod : (__ : x1 -> __1 : x1 -> x1) -> _null : (a : x1 -> Eq (prod a x2) x2) -> _distr : (a : x1 -> b : x1 -> c : x1 -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> _z1741 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm .
Dop_inv_rect_CProp2 : x1 : Set -> x2 : x1 -> Hterm : Dop x1 x2 -> P : (_z1746 : Dop x1 x2 -> Prop) -> _H1 : (sum : ACop x1 x2 -> prod : (__ : x1 -> __1 : x1 -> x1) -> _null : (a : x1 -> Eq (prod a x2) x2) -> _distr : (a : x1 -> b : x1 -> c : x1 -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> _z1747 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm .
Dop_inv_rect_CProp1 : x1 : Set -> x2 : x1 -> Hterm : Dop x1 x2 -> P : (_z1752 : Dop x1 x2 -> Prop) -> _H1 : (sum : ACop x1 x2 -> prod : (__ : x1 -> __1 : x1 -> x1) -> _null : (a : x1 -> Eq (prod a x2) x2) -> _distr : (a : x1 -> b : x1 -> c : x1 -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> _z1753 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm .
Dop_inv_rect_CProp0 : x1 : Set -> x2 : x1 -> Hterm : Dop x1 x2 -> P : (_z1758 : Dop x1 x2 -> Prop) -> _H1 : (sum : ACop x1 x2 -> prod : (__ : x1 -> __1 : x1 -> x1) -> _null : (a : x1 -> Eq (prod a x2) x2) -> _distr : (a : x1 -> b : x1 -> c : x1 -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> _z1759 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm .
Dop_discr : a1 : Set -> a2 : a1 -> x : Dop a1 a2 -> y : Dop a1 a2 -> _e : Eq x y -> match_Dop a1 a2 (plus Type2 (nd 1)) (__ : Dop a1 a2 => univ Type2) (t0 : ACop a1 a2 => t1 : (__ : a1 -> __1 : a1 -> a1) => t2 : (a : a1 -> Eq (t1 a a2) a2) => t3 : (a : a1 -> b : a1 -> c : a1 -> Eq (t1 a (aop__o__op a1 a2 t0 b c)) (aop__o__op a1 a2 t0 (t1 a b) (t1 a c))) => match_Dop a1 a2 (plus Type2 (nd 1)) (__ : Dop a1 a2 => univ Type2) (u0 : ACop a1 a2 => u1 : (__ : a1 -> __1 : a1 -> a1) => u2 : (a : a1 -> Eq (u1 a a2) a2) => u3 : (a : a1 -> b : a1 -> c : a1 -> Eq (u1 a (aop__o__op a1 a2 u0 b c)) (aop__o__op a1 a2 u0 (u1 a b) (u1 a c))) => prod (plus Type1 (nd 1)) Type1 (univ Type1) (P : Type1 => prod Type1 Type1 (prod Prop Type1 (Eq (R0 (ACop a1 a2) t0) u0) (e0 : Eq (R0 (ACop a1 a2) t0) u0 => prod Prop Type1 (Eq (R1 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 u0 e0) u1) (e1 : Eq (R1 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 u0 e0) u1 => prod Prop Type1 (Eq (R2 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => x1 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x0 p0 => __ : Eq (R1 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x0 p0) x1 => (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__1 : a1 -> __2 : a1 -> a1) => p1 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x11 a a2) a2)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2) (e2 : Eq (R2 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => x1 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x0 p0 => __ : Eq (R1 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x0 p0) x1 => (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__1 : a1 -> __2 : a1 -> a1) => p1 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x11 a a2) a2)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2 => prod Prop Type1 (Eq (R3 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => x1 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x0 p0 => __ : Eq (R1 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x0 p0) x1 => (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__1 : a1 -> __2 : a1 -> a1) => p1 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x11 a a2) a2)) x0 p0 x1 __) t2 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => x1 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x0 p0 => p1 : Eq (R1 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x0 p0) x1 => x2 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__ : a1 -> __1 : a1 -> a1) => p11 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x11 a a2) a2)) x0 p0 x1 p1 => __ : Eq (R2 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (x02 : ACop a1 a2 => p02 : Eq t0 x02 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x01 p01 => __ : Eq (R1 (ACop a1 a2) t0 (x02 : ACop a1 a2 => p02 : Eq t0 x02 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x01 p01) x11 => (x02 : ACop a1 a2 => p02 : Eq t0 x02 => x12 : (__1 : a1 -> __2 : a1 -> a1) => p11 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x02 p02) x12 => prod Set Prop a1 (a : a1 => Eq (x12 a a2) a2)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 => (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__1 : a1 -> __2 : a1 -> a1) => p11 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x01 p01) x11 => x21 : (a : a1 -> Eq (x11 a a2) a2) => p2 : Eq (R2 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 (x02 : ACop a1 a2 => p02 : Eq t0 x02 => x12 : (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) x02 p02 => __1 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x02 p02) x12 => (x00 : ACop a1 a2 => p00 : Eq t0 x00 => x10 : (__2 : a1 -> __3 : a1 -> a1) => p10 : Eq (R1 (ACop a1 a2) t0 (x011 : ACop a1 a2 => p011 : Eq t0 x011 => prod Set Set a1 (__2 : a1 => prod Set Set a1 (__3 : a1 => a1))) t1 x00 p00) x10 => prod Set Prop a1 (a : a1 => Eq (x10 a a2) a2)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 => prod Set Prop a1 (a : a1 => prod Set Prop a1 (b : a1 => prod Set Prop a1 (c : a1 => Eq (x11 a (aop__o__op a1 a2 x01 b c)) (aop__o__op a1 a2 x01 (x11 a b) (x11 a c)))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3) (_e3 : Eq (R3 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => x1 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x0 p0 => __ : Eq (R1 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x0 p0) x1 => (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__1 : a1 -> __2 : a1 -> a1) => p1 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x11 a a2) a2)) x0 p0 x1 __) t2 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => x1 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x0 p0 => p1 : Eq (R1 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x0 p0) x1 => x2 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__ : a1 -> __1 : a1 -> a1) => p11 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x11 a a2) a2)) x0 p0 x1 p1 => __ : Eq (R2 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (x02 : ACop a1 a2 => p02 : Eq t0 x02 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x01 p01 => __ : Eq (R1 (ACop a1 a2) t0 (x02 : ACop a1 a2 => p02 : Eq t0 x02 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x01 p01) x11 => (x02 : ACop a1 a2 => p02 : Eq t0 x02 => x12 : (__1 : a1 -> __2 : a1 -> a1) => p11 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x02 p02) x12 => prod Set Prop a1 (a : a1 => Eq (x12 a a2) a2)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 => (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__1 : a1 -> __2 : a1 -> a1) => p11 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x01 p01) x11 => x21 : (a : a1 -> Eq (x11 a a2) a2) => p2 : Eq (R2 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 (x02 : ACop a1 a2 => p02 : Eq t0 x02 => x12 : (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) x02 p02 => __1 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x02 p02) x12 => (x00 : ACop a1 a2 => p00 : Eq t0 x00 => x10 : (__2 : a1 -> __3 : a1 -> a1) => p10 : Eq (R1 (ACop a1 a2) t0 (x011 : ACop a1 a2 => p011 : Eq t0 x011 => prod Set Set a1 (__2 : a1 => prod Set Set a1 (__3 : a1 => a1))) t1 x00 p00) x10 => prod Set Prop a1 (a : a1 => Eq (x10 a a2) a2)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 => prod Set Prop a1 (a : a1 => prod Set Prop a1 (b : a1 => prod Set Prop a1 (c : a1 => Eq (x11 a (aop__o__op a1 a2 x01 b c)) (aop__o__op a1 a2 x01 (x11 a b) (x11 a c)))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3 => P))))) (_z61 : (e0 : Eq (R0 (ACop a1 a2) t0) u0 -> e1 : Eq (R1 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 u0 e0) u1 -> e2 : Eq (R2 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => x1 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x0 p0 => __ : Eq (R1 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x0 p0) x1 => (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__1 : a1 -> __2 : a1 -> a1) => p1 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x11 a a2) a2)) x0 p0 x1 __) t2 u0 e0 u1 e1) u2 -> _e3 : Eq (R3 (ACop a1 a2) t0 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => x1 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x0 p0 => __ : Eq (R1 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x0 p0) x1 => (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__1 : a1 -> __2 : a1 -> a1) => p1 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x11 a a2) a2)) x0 p0 x1 __) t2 (x0 : ACop a1 a2 => p0 : Eq t0 x0 => x1 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x0 p0 => p1 : Eq (R1 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x0 p0) x1 => x2 : (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__ : a1 -> __1 : a1 -> a1) => p11 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x01 p01) x11 => prod Set Prop a1 (a : a1 => Eq (x11 a a2) a2)) x0 p0 x1 p1 => __ : Eq (R2 (ACop a1 a2) t0 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (x02 : ACop a1 a2 => p02 : Eq t0 x02 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) x01 p01 => __ : Eq (R1 (ACop a1 a2) t0 (x02 : ACop a1 a2 => p02 : Eq t0 x02 => prod Set Set a1 (__ : a1 => prod Set Set a1 (__1 : a1 => a1))) t1 x01 p01) x11 => (x02 : ACop a1 a2 => p02 : Eq t0 x02 => x12 : (__1 : a1 -> __2 : a1 -> a1) => p11 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x02 p02) x12 => prod Set Prop a1 (a : a1 => Eq (x12 a a2) a2)) x01 p01 x11 __) t2 x0 p0 x1 p1) x2 => (x01 : ACop a1 a2 => p01 : Eq t0 x01 => x11 : (__1 : a1 -> __2 : a1 -> a1) => p11 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x01 p01) x11 => x21 : (a : a1 -> Eq (x11 a a2) a2) => p2 : Eq (R2 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 (x02 : ACop a1 a2 => p02 : Eq t0 x02 => x12 : (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) x02 p02 => __1 : Eq (R1 (ACop a1 a2) t0 (x00 : ACop a1 a2 => p00 : Eq t0 x00 => prod Set Set a1 (__1 : a1 => prod Set Set a1 (__2 : a1 => a1))) t1 x02 p02) x12 => (x00 : ACop a1 a2 => p00 : Eq t0 x00 => x10 : (__2 : a1 -> __3 : a1 -> a1) => p10 : Eq (R1 (ACop a1 a2) t0 (x011 : ACop a1 a2 => p011 : Eq t0 x011 => prod Set Set a1 (__2 : a1 => prod Set Set a1 (__3 : a1 => a1))) t1 x00 p00) x10 => prod Set Prop a1 (a : a1 => Eq (x10 a a2) a2)) x02 p02 x12 __1) t2 x01 p01 x11 p11) x21 => prod Set Prop a1 (a : a1 => prod Set Prop a1 (b : a1 => prod Set Prop a1 (c : a1 => Eq (x11 a (aop__o__op a1 a2 x01 b c)) (aop__o__op a1 a2 x01 (x11 a b) (x11 a c)))))) x0 p0 x1 p1 x2 __) t3 u0 e0 u1 e1 u2 e2) u3 -> P) => P))) y) x .
let_aop : n : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> R : Dop B nil -> f : (__ : Nat -> B) -> a : B -> ACop B nil .
let_mop : n : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> R : Dop B nil -> f : (__ : Nat -> B) -> a : B -> _x_969 : B -> _x_970 : B -> B .
bigop_distr : n : Nat -> p : (__ : Nat -> bool) -> B : Set -> nil : B -> R : Dop B nil -> f : (__ : Nat -> B) -> a : B -> Eq (let_mop n p B nil R f a a (bigop n (i : Nat => p i) B nil (aop__o__op B nil (let_aop n p B nil R f a)) (i : Nat => f i))) (bigop n (i : Nat => p i) B nil (aop__o__op B nil (let_aop n p B nil R f a)) (i : Nat => let_mop n p B nil R f a a (f i))) .
bc : _n : Nat -> _k : Nat -> Nat .
bceq : n : Nat -> k : Nat -> Eq (bc n k) (div (factorial n) (times (factorial k) (factorial (minus n k)))) .
bc_n_n : n : Nat -> Eq (bc n n) (nd 1) .
bc_n_O : n : Nat -> Eq (bc n 0) (nd 1) .
fact_minus : n : Nat -> k : Nat -> __ : Lt k n -> Eq (times (factorial (minus n (plus k (nd 1)))) (minus n k)) (factorial (minus n k)) .
bc2 : n : Nat -> k : Nat -> __ : Leq k n -> divisible (times (factorial k) (factorial (minus n k))) (factorial n) .
bc1 : n : Nat -> k : Nat -> __ : Lt k n -> Eq (bc (plus n (nd 1)) (plus k (nd 1))) (plus (bc n k) (bc n (plus k (nd 1)))) .
lt_O_bc : n : Nat -> m : Nat -> __ : Leq m n -> Lt 0 (bc n m) .
binomial_law : a : Nat -> b : Nat -> n : Nat -> Eq (pow (plus a b) n) (bigop (plus n (nd 1)) (k : Nat => true) Nat 0 plus (k : Nat => times (times (bc n k) (pow a (minus n k))) (pow b k))) .
exp_S_sigma_p : a : Nat -> n : Nat -> Eq (pow (plus a (nd 1)) n) (bigop (plus n (nd 1)) (k : Nat => true) Nat 0 plus (k : Nat => times (bc n k) (pow a (minus n k)))) .
eqb_sym : a : Nat -> b : Nat -> Eq (eqb a b) (eqb b a) .
M : _m : Nat -> Nat .
Mdef : m : Nat -> Eq (M m) (bc (plus (times (nd 2) m) (nd 1)) m) .
let_clause_1692 : m : Nat -> posm : Lt 0 m -> a : Nat -> x358 : Nat -> x359 : Nat -> Eq (aop__o__op Nat 0 plusAC x358 (times x358 x359)) (times x358 (plus x359 (nd 1))) .
let_clause_1704 : m : Nat -> posm : Lt 0 m -> a : Nat -> x1029 : Nat -> Eq x1029 (aop__o__op Nat 0 plusAC x1029 0) .
let_clause_16921 : m : Nat -> posm : Lt 0 m -> a : Nat -> x358 : Nat -> x359 : Nat -> Eq (aop__o__op Nat 0 plusAC x358 (times x358 x359)) (times x358 (plus x359 (nd 1))) .
let_clause_17041 : m : Nat -> posm : Lt 0 m -> a : Nat -> x1029 : Nat -> Eq x1029 (aop__o__op Nat 0 plusAC x1029 0) .
lt_M : m : Nat -> __ : Lt 0 m -> Lt (M m) (pow (nd 2) (times (nd 2) m)) .
decidable_not : P : Prop -> __ : decidable P -> decidable (not P) .
decidable_or : P : Prop -> Q : Prop -> __ : decidable P -> __1 : decidable Q -> decidable (or P Q) .
decidable_forall : P : (__ : Nat -> Prop) -> __ : (i : Nat -> decidable (P i)) -> n : Nat -> decidable (prod Set Prop Nat (i : Nat => prod Prop Prop (Lt i n) (__1 : Lt i n => P i))) .
not_exists_to_forall : P : (__ : Nat -> Prop) -> n : Nat -> __ : not (ex Nat (i : Nat => and (Lt i n) (P i))) -> i : Nat -> __1 : Lt i n -> not (P i) .
not_forall_to_exists : P : (__ : Nat -> Prop) -> n : Nat -> __ : (i : Nat -> decidable (P i)) -> __1 : not (prod Set Prop Nat (i : Nat => prod Prop Prop (Lt i n) (__1 : Lt i n => P i))) -> ex Nat (i : Nat => and (Lt i n) (not (P i))) .
bertrand : _n : Nat -> Prop .
not_bertrand : _n : Nat -> Prop .
min_prim : n : Nat -> ex Nat (p : Nat => and (and (Lt n p) (prime p)) (prod Set Prop Nat (q : Nat => prod Prop Prop (prime q) (__ : prime q => prod Prop Prop (Lt q p) (__1 : Lt q p => Leq q n))))) .
not_not_bertrand_to_bertrand1 : n : Nat -> __ : not (not_bertrand n) -> x : Nat -> __1 : Leq n x -> __2 : Leq x (times (nd 2) n) -> __3 : (p : Nat -> __3 : Lt x p -> __4 : Leq p (times (nd 2) n) -> not (prime p)) -> ex Nat (p : Nat => and (and (Lt n p) (Leq p x)) (prime p)) .
not_not_bertrand_to_bertrand : n : Nat -> __ : not (not_bertrand n) -> bertrand n .
k : _n : Nat -> _p : Nat -> Nat .
k_def : n : Nat -> p : Nat -> Eq (k n p) (bigop (log p n) (i : Nat => true) Nat 0 plus (i : Nat => mod (div n (pow p (plus i (nd 1)))) (nd 2))) .
le_k : n : Nat -> p : Nat -> Leq (k n p) (log p n) .
Bk : _n : Nat -> Nat .
Bk_def : n : Nat -> Eq (Bk n) (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => pow p (k n p))) .
Dexp : Dop Nat (nd 1) .
eq_B_Bk : n : Nat -> Eq (B n) (Bk n) .
B1 : _n : Nat -> Nat .
B1_def : n : Nat -> Eq (B1 n) (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => pow p (times (bool_to_nat (leb (k n p) (nd 1))) (k n p)))) .
B2 : _n : Nat -> Nat .
B2_def : n : Nat -> Eq (B2 n) (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => pow p (times (bool_to_nat (leb (nd 2) (k n p))) (k n p)))) .
eq_Bk_B1_B2 : n : Nat -> Eq (Bk n) (times (B1 n) (B2 n)) .
lt_div_to_times : n : Nat -> m : Nat -> q : Nat -> __ : Lt 0 q -> __1 : Lt (div n q) m -> Lt n (times q m) .
lt_to_div_O : n : Nat -> m : Nat -> __ : Lt n m -> Eq (div n m) 0 .
k1 : n : Nat -> p : Nat -> __ : Leq (nn 1 (nd 8)) n -> __1 : Leq p n -> __2 : Lt (div (times (nd 2) n) (nd 3)) p -> Eq (k (times (nd 2) n) p) 0 .
le_B1_theta : n : Nat -> __ : Leq (nn 1 (nd 8)) n -> __1 : not_bertrand n -> Leq (B1 (times (nd 2) n)) (theta (div (times (nd 2) n) (nd 3))) .
let_clause_1033 : n : Nat -> len : Leq (pow (nd 2) (nd 7)) n -> p : Nat -> lep : Leq (plus (sqrt (times (nd 2) n)) (nd 1)) p -> ltp : Lt p (plus (times (nd 2) n) (nd 1)) -> Hc : Eq (leb (nd 2) (k (times (nd 2) n) p)) true -> H2n : Lt (times (nd 2) n) (pow p (nd 2)) -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
le_B2_exp : n : Nat -> __ : Leq (pow (nd 2) (nd 7)) n -> Leq (B2 (times (nd 2) n)) (pow (times (nd 2) n) (pred (div (sqrt (times (nd 2) n)) (nd 2)))) .
not_bertrand_to_le_B : n : Nat -> __ : Leq (pow (nd 2) (nd 7)) n -> __1 : not_bertrand n -> Leq (B (times (nd 2) n)) (times (pow (nd 2) (times (nd 2) (div (times (nd 2) n) (nd 3)))) (pow (times (nd 2) n) (pred (div (sqrt (times (nd 2) n)) (nd 2))))) .
le_times_div_m_m : n : Nat -> m : Nat -> __ : Lt 0 m -> Leq (times (div n m) m) n .
not_bertrand_to_le1 : n : Nat -> __ : Leq (pow (nd 2) (nd 7)) n -> __1 : not_bertrand n -> Leq (pow (nd 2) (div (times (nd 2) n) (nd 3))) (pow (times (nd 2) n) (div (sqrt (times (nd 2) n)) (nd 2))) .
not_bertrand_to_le2 : n : Nat -> __ : Leq (pow (nd 2) (nd 7)) n -> __1 : not_bertrand n -> Leq (div (times (nd 2) n) (nd 3)) (times (div (sqrt (times (nd 2) n)) (nd 2)) (plus (log (nd 2) (times (nd 2) n)) (nd 1))) .
lt_div_S_div : n : Nat -> m : Nat -> __ : Lt 0 m -> __1 : Leq (pow m (nd 2)) n -> Lt (div n (plus m (nd 1))) (div n m) .
times_div_le : a : Nat -> b : Nat -> c : Nat -> d : Nat -> __ : Lt 0 b -> __1 : Lt 0 d -> Leq (times (div a b) (div c d)) (div (times a c) (times b d)) .
tech : n : Nat -> __ : Leq (times (nd 2) (plus (log (nd 2) (times (nd 2) n)) (nd 1))) (sqrt (times (nd 2) n)) -> Leq (times (div (sqrt (times (nd 2) n)) (nd 2)) (plus (log (nd 2) (times (nd 2) n)) (nd 1))) (div (times (nd 2) n) (nd 4)) .
exp_to_log_r : b : Nat -> n : Nat -> m : Nat -> __ : Lt (nd 1) b -> __1 : Lt n m -> __2 : Leq (pow b n) m -> Leq n (log b m) .
let_clause_73 : n : Nat -> posn : Lt (nd 2) n -> x134 : Nat -> x135 : Nat -> x136 : Nat -> Eq (plus x134 (plus x135 x136)) (plus x135 (plus x134 x136)) .
square_double : n : Nat -> __ : Lt (nd 2) n -> Leq (times (plus n (nd 1)) (plus n (nd 1))) (times (times (nd 2) n) n) .
let_clause_10331 : n : Nat -> len : Leq (pow (nd 2) (nd 8)) n -> m : Nat -> lt2m : Leq (nd 3) m -> Hind : Leq (plus (log (nd 2) m) (nd 2)) m -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
sqrt_bound : n : Nat -> __ : Leq (pow (nd 2) (nd 8)) n -> Leq (times (nd 2) (plus (log (nd 2) (times (nd 2) n)) (nd 1))) (sqrt (times (nd 2) n)) .
bertrand_up : n : Nat -> __ : Leq (pow (nd 2) (nd 8)) n -> bertrand n .
list_divides : __ : list Nat -> __1 : Nat -> bool .
list_divides_body : __ : list Nat -> __1 : Nat -> bool .
list_divides_true : l : list Nat -> n : Nat -> __ : Eq (list_divides l n) true -> ex Nat (p : Nat => and (mem Nat p l) (divisible p n)) .
list_divides_false : l : list Nat -> n : Nat -> __ : Eq (list_divides l n) false -> p : Nat -> __1 : mem Nat p l -> not (divisible p n) .
lprim : __ : Nat -> __1 : Nat -> __2 : list Nat -> list Nat .
lprim_body : __ : Nat -> __1 : Nat -> __2 : list Nat -> list Nat .
list_of_primes : _n : Nat -> list Nat .
lop_Strue : m : Nat -> i : Nat -> acc : list Nat -> __ : Eq (list_divides acc i) true -> Eq (lprim (plus m (nd 1)) i acc) (lprim m (plus i (nd 1)) acc) .
lop_Sfalse : m : Nat -> i : Nat -> acc : list Nat -> __ : Eq (list_divides acc i) false -> Eq (lprim (plus m (nd 1)) i acc) (lprim m (plus i (nd 1)) (append Nat acc (cons Nat i (nil Nat)))) .
list_of_primes_def : n : Nat -> Eq (list_of_primes n) (lprim n (nd 2) (nil Nat)) .
lprim_ex : Eq (lprim (nd 8) (nd 2) (nil Nat)) (cons Nat (nd 2) (cons Nat (nd 3) (cons Nat (nd 5) (cons Nat (nd 7) (nil Nat))))) .
start_lprim : n : Nat -> m : Nat -> a : Nat -> acc : list Nat -> Eq (option_hd Nat (lprim n m (cons Nat a acc))) (Some Nat a) .
start_lop : n : Nat -> __ : Leq (nd 1) n -> Eq (option_hd Nat (list_of_primes n)) (Some Nat (nd 2)) .
eq_lop : n : Nat -> __ : Leq (nd 1) n -> Eq (list_of_primes n) (cons Nat (nd 2) (tail Nat (list_of_primes n))) .
all_primes : _l : list Nat -> Prop .
all_below : _l : list Nat -> _n : Nat -> Prop .
primes_all : _l : list Nat -> _n : Nat -> Prop .
primes_below : _l : list Nat -> _n : Nat -> Prop .
ld_to_prime : i : Nat -> acc : list Nat -> __ : Lt (nd 1) i -> __1 : primes_below acc i -> __2 : Eq (list_divides acc i) false -> prime i .
lprim_invariant : n : Nat -> i : Nat -> acc : list Nat -> __ : Lt (nd 1) i -> __1 : primes_below acc i -> primes_below (lprim n i acc) (plus n i) .
primes_below2 : primes_below (nil Nat) (nd 2) .
let_clause_1033 : n : Nat -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
primes_below_lop : n : Nat -> primes_below (list_of_primes n) (plus n (nd 2)) .
primes_below_to_bertrand : pm : Nat -> l : list Nat -> __ : prime pm -> __1 : primes_below l (plus pm (nd 1)) -> __2 : (p : Nat -> __2 : mem Nat p l -> __3 : Lt (nd 2) p -> ex Nat (pp : Nat => and (and (mem Nat pp l) (Lt pp p)) (Leq p (times (nd 2) pp)))) -> n : Nat -> __3 : Lt 0 n -> __4 : Lt n pm -> bertrand n .
checker : __ : list Nat -> bool .
checker_body : __ : list Nat -> bool .
checker_ab : a : Nat -> b : Nat -> l : list Nat -> Eq (checker (cons Nat a (cons Nat b l))) (andb (andb (leb (plus a (nd 1)) b) (leb b (times (nd 2) a))) (checker (cons Nat b l))) .
checker_abl : a : Nat -> b : Nat -> l : list Nat -> __ : Eq (checker (cons Nat a (cons Nat b l))) true -> and (and (Lt a b) (Leq b (times (nd 2) a))) (Eq (checker (cons Nat b l)) true) .
checker_spec : tl : list Nat -> a : Nat -> l : list Nat -> __ : Eq (checker l) true -> __1 : Eq l (cons Nat a tl) -> p : Nat -> __2 : mem Nat p tl -> ex Nat (pp : Nat => and (and (mem Nat pp l) (Lt pp p)) (Leq p (times (nd 2) pp))) .
bertrand_down : n : Nat -> __ : Lt 0 n -> __1 : Leq n (pow (nd 2) (nd 8)) -> bertrand n .
bertrand : n : Nat -> __ : Lt 0 n -> bertrand n .
prim : _n : Nat -> Nat .
le_prim_n : n : Nat -> Leq (prim n) n .
let_clause_1033 : n : Nat -> ltn : Lt (nd 1) n -> _clearme : prime (times (nd 2) n) -> H : Lt (nd 1) (times (nd 2) n) -> H1 : (m : Nat -> __ : divisible m (times (nd 2) n) -> __1 : Lt (nd 1) m -> Eq m (times (nd 2) n)) -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
not_prime_times_2 : n : Nat -> __ : Lt (nd 1) n -> not (prime (times (nd 2) n)) .
eq_prim_prim_pred : n : Nat -> __ : Lt (nd 1) n -> Eq (prim (times (nd 2) n)) (prim (pred (times (nd 2) n))) .
le_prim_n1 : n : Nat -> __ : Leq (nd 4) n -> Leq (prim (plus (times (nd 2) n) (nd 1))) n .
le_prim_n2 : n : Nat -> __ : Leq (nd 7) n -> Leq (prim (plus (times (nd 2) n) (nd 1))) (pred n) .
let_clause_1553 : n : Nat -> n0 : Nat -> _clearme : ex Nat (a : Nat => or (Eq n0 (times (nd 2) a)) (Eq n0 (plus (times (nd 2) a) (nd 1)))) -> a : Nat -> _clearme0 : or (Eq n0 (times (nd 2) a)) (Eq n0 (plus (times (nd 2) a) (nd 1))) -> Hn : Eq n0 (plus (times (nd 2) a) (nd 1)) -> Eq n0 (plus a (plus a (nd 1))) .
even_or_odd : n : Nat -> ex Nat (a : Nat => or (Eq n (times (nd 2) a)) (Eq n (plus (times (nd 2) a) (nd 1)))) .
le_prim_n3 : n : Nat -> __ : Leq (nn 1 (nd 5)) n -> Leq (prim n) (pred (div n (nd 2))) .
Psi : __ : Nat -> Nat .
psi_def : n : Nat -> Eq (Psi n) (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => pow p (log p n))) .
le_Psil1 : n : Nat -> Leq (Psi n) (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => n)) .
le_Psil : n : Nat -> Leq (Psi n) (pow n (prim n)) .
lePsi_r2 : n : Nat -> Leq (pow n (prim n)) (times (Psi n) (Psi n)) .
Psi' : __ : Nat -> Nat .
Psidef : n : Nat -> Eq (Psi' n) (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => bigop (log p n) (i : Nat => true) Nat (nd 1) times (i : Nat => p))) .
eq_Psi_Psi' : n : Nat -> Eq (Psi n) (Psi' n) .
theta : __ : Nat -> Nat .
theta_def : n : Nat -> Eq (theta n) (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => p)) .
lt_O_theta : n : Nat -> Lt 0 (theta n) .
divides_fact_to_divides : p : Nat -> n : Nat -> __ : prime p -> __1 : divisible p (factorial n) -> ex Nat (m : Nat => and (and (Lt 0 m) (Leq m n)) (divisible p m)) .
divides_fact_to_le : p : Nat -> n : Nat -> __ : prime p -> __1 : divisible p (factorial n) -> Leq p n .
prime_to_divides_M : m : Nat -> p : Nat -> __ : prime p -> __1 : Lt (plus m (nd 1)) p -> __2 : Leq p (plus (times (nd 2) m) (nd 1)) -> divisible p (M m) .
divides_pi_p_M1 : m : Nat -> i : Nat -> __ : Leq i (plus (times (nd 2) m) (nd 2)) -> divisible (bigop i (p : Nat => andb (leb (plus m (nd 2)) p) (primeb p)) Nat (nd 1) times (p : Nat => p)) (M m) .
divides_pi_p_M : m : Nat -> divisible (bigop (plus (times (nd 2) m) (nd 2)) (p : Nat => andb (leb (plus m (nd 2)) p) (primeb p)) Nat (nd 1) times (p : Nat => p)) (M m) .
theta_pi_p_theta : m : Nat -> Eq (theta (plus (times (nd 2) m) (nd 1))) (times (bigop (plus (times (nd 2) m) (nd 2)) (p : Nat => andb (leb (plus m (nd 2)) p) (primeb p)) Nat (nd 1) times (p : Nat => p)) (theta (plus m (nd 1)))) .
div_theta_theta : m : Nat -> Eq (div (theta (plus (times (nd 2) m) (nd 1))) (theta (plus m (nd 1)))) (bigop (plus (times (nd 2) m) (nd 2)) (p : Nat => andb (leb (plus m (nd 2)) p) (primeb p)) Nat (nd 1) times (p : Nat => p)) .
le_theta_M_theta : m : Nat -> Leq (theta (plus (times (nd 2) m) (nd 1))) (times (M m) (theta (plus m (nd 1)))) .
lt_O_to_le_theta_exp_theta : m : Nat -> __ : Lt 0 m -> Lt (theta (plus (times (nd 2) m) (nd 1))) (times (pow (nd 2) (times (nd 2) m)) (theta (plus m (nd 1)))) .
let_clause_1033 : n : Nat -> lt1n : Lt (nd 1) n -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
theta_pred : n : Nat -> __ : Lt (nd 1) n -> Eq (theta (times (nd 2) n)) (theta (pred (times (nd 2) n))) .
le_theta : m : Nat -> Leq (theta m) (pow (nd 2) (times (nd 2) m)) .
eq_pi_p_primeb_divides_b : n : Nat -> m : Nat -> Eq (bigop n (p : Nat => andb (primeb p) (dividesb p m)) Nat (nd 1) times (p : Nat => pow p (ord m p))) (bigop n (p : Nat => primeb p) Nat (nd 1) times (p : Nat => pow p (ord m p))) .
lt_1_max_prime : n : Nat -> __ : Lt (nd 1) n -> Lt (nd 1) (max (plus n (nd 1)) (i : Nat => andb (primeb i) (dividesb i n))) .
lt_max_to_pi_p_primeb : q : Nat -> m : Nat -> __ : Lt 0 m -> __1 : Lt (max (plus m (nd 1)) (i : Nat => andb (primeb i) (dividesb i m))) q -> Eq m (bigop q (p : Nat => andb (primeb p) (dividesb p m)) Nat (nd 1) times (p : Nat => pow p (ord m p))) .
pi_p_primeb_dividesb : n : Nat -> __ : Lt 0 n -> Eq n (bigop (plus n (nd 1)) (p : Nat => andb (primeb p) (dividesb p n)) Nat (nd 1) times (p : Nat => pow p (ord n p))) .
pi_p_primeb : n : Nat -> __ : Lt 0 n -> Eq n (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => pow p (ord n p))) .
le_ord_log : n : Nat -> p : Nat -> __ : Lt 0 n -> __1 : Lt (nd 1) p -> Leq (ord n p) (log p n) .
sigma_p_dividesb : m : Nat -> n : Nat -> p : Nat -> __ : Lt 0 n -> __1 : prime p -> __2 : not (divisible p n) -> Eq m (bigop m (i : Nat => dividesb (pow p (plus i (nd 1))) (times (pow p m) n)) Nat 0 plus (i : Nat => nd 1)) .
sigma_p_dividesb1 : m : Nat -> n : Nat -> p : Nat -> k : Nat -> __ : Lt 0 n -> __1 : prime p -> __2 : not (divisible p n) -> __3 : Leq m k -> Eq m (bigop k (i : Nat => dividesb (pow p (plus i (nd 1))) (times (pow p m) n)) Nat 0 plus (i : Nat => nd 1)) .
eq_ord_sigma_p : n : Nat -> m : Nat -> x : Nat -> __ : Lt 0 n -> __1 : prime x -> __2 : Leq (pow x m) n -> __3 : Lt n (pow x (plus m (nd 1))) -> Eq (ord n x) (bigop m (i : Nat => dividesb (pow x (plus i (nd 1))) n) Nat 0 plus (i : Nat => nd 1)) .
pi_p_primeb1 : n : Nat -> __ : Lt 0 n -> Eq n (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => bigop (log p n) (i : Nat => dividesb (pow p (plus i (nd 1))) n) Nat (nd 1) times (i : Nat => p))) .
eq_fact_pi_p : n : Nat -> Eq (factorial n) (bigop (plus n (nd 1)) (i : Nat => leb (nd 1) i) Nat (nd 1) times (i : Nat => i)) .
let_clause_1648 : n : Nat -> q : Nat -> posq : Lt 0 q -> n1 : Nat -> Hind : Eq n1 (plus (times (bigop (plus n1 (nd 1)) (m : Nat => andb (leb (nd 1) m) (dividesb q m)) Nat 0 plus (m : Nat => nd 1)) q) (mod n1 q)) -> _clearme : and (divisible q (plus n1 (nd 1))) (Eq (plus n1 (nd 1)) (times (plus (div n1 q) (nd 1)) q)) -> divq : divisible q (plus n1 (nd 1)) -> eqn1 : Eq (plus n1 (nd 1)) (times (plus (div n1 q) (nd 1)) q) -> Eq (plus n1 (nd 1)) (plus q (times q (div n1 q))) .
eq_sigma_p_div : n : Nat -> q : Nat -> __ : Lt 0 q -> Eq (bigop (plus n (nd 1)) (m : Nat => andb (leb (nd 1) m) (dividesb q m)) Nat 0 plus (m : Nat => nd 1)) (div n q) .
timesACdef : n : Nat -> m : Nat -> Eq (aop__o__op Nat (nd 1) timesAC n m) (times n m) .
fact_pi_p : n : Nat -> Eq (factorial n) (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => bigop (log p n) (i : Nat => true) Nat (nd 1) times (i : Nat => pow p (div n (pow p (plus i (nd 1))))))) .
fact_pi_p2 : n : Nat -> Eq (factorial (times (nd 2) n)) (bigop (plus (times (nd 2) n) (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => bigop (log p (times (nd 2) n)) (i : Nat => true) Nat (nd 1) times (i : Nat => times (pow p (times (nd 2) (div n (pow p (plus i (nd 1)))))) (pow p (mod (div (times (nd 2) n) (pow p (plus i (nd 1)))) (nd 2)))))) .
fact_pi_p3 : n : Nat -> Eq (factorial (times (nd 2) n)) (times (bigop (plus (times (nd 2) n) (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => bigop (log p (times (nd 2) n)) (i : Nat => true) Nat (nd 1) times (i : Nat => pow p (times (nd 2) (div n (pow p (plus i (nd 1)))))))) (bigop (plus (times (nd 2) n) (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => bigop (log p (times (nd 2) n)) (i : Nat => true) Nat (nd 1) times (i : Nat => pow p (mod (div (times (nd 2) n) (pow p (plus i (nd 1)))) (nd 2)))))) .
pi_p_primeb4 : n : Nat -> __ : Lt (nd 1) n -> Eq (bigop (plus (times (nd 2) n) (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => bigop (log p (times (nd 2) n)) (i : Nat => true) Nat (nd 1) times (i : Nat => pow p (times (nd 2) (div n (pow p (plus i (nd 1)))))))) (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => bigop (log p (times (nd 2) n)) (i : Nat => true) Nat (nd 1) times (i : Nat => pow p (times (nd 2) (div n (pow p (plus i (nd 1)))))))) .
pi_p_primeb5 : n : Nat -> __ : Lt (nd 1) n -> Eq (bigop (plus (times (nd 2) n) (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => bigop (log p (times (nd 2) n)) (i : Nat => true) Nat (nd 1) times (i : Nat => pow p (times (nd 2) (div n (pow p (plus i (nd 1)))))))) (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => bigop (log p n) (i : Nat => true) Nat (nd 1) times (i : Nat => pow p (times (nd 2) (div n (pow p (plus i (nd 1)))))))) .
exp_fact_2 : n : Nat -> Eq (pow (factorial n) (nd 2)) (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => bigop (log p n) (i : Nat => true) Nat (nd 1) times (i : Nat => pow p (times (nd 2) (div n (pow p (plus i (nd 1)))))))) .
B : _n : Nat -> Nat .
Bdef : n : Nat -> Eq (B n) (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => bigop (log p n) (i : Nat => true) Nat (nd 1) times (i : Nat => pow p (mod (div n (pow p (plus i (nd 1)))) (nd 2))))) .
B_SSSO : Eq (B (nd 3)) (nd 6) .
B_SSSSO : Eq (B (nd 4)) (nd 6) .
B_SSSSSO : Eq (B (nd 5)) (nn 3 (nd 0)) .
B_SSSSSSO : Eq (B (nd 6)) (nn 2 (nd 0)) .
B_SSSSSSSO : Eq (B (nd 7)) (nn 1 (nn 4 (nd 0))) .
B_SSSSSSSSO : Eq (B (nd 8)) (nn 7 (nd 0)) .
eq_fact_B : n : Nat -> __ : Lt (nd 1) n -> Eq (factorial (times (nd 2) n)) (times (pow (factorial n) (nd 2)) (B (times (nd 2) n))) .
lt_SO_to_le_B_exp : n : Nat -> __ : Lt (nd 1) n -> Leq (B (times (nd 2) n)) (pow (nd 2) (pred (times (nd 2) n))) .
le_B_exp : n : Nat -> Leq (B (times (nd 2) n)) (pow (nd 2) (pred (times (nd 2) n))) .
lt_4_to_le_B_exp : n : Nat -> __ : Lt (nd 4) n -> Leq (B (times (nd 2) n)) (pow (nd 2) (minus (times (nd 2) n) (nd 2))) .
lt_1_to_le_exp_B : n : Nat -> __ : Lt (nd 1) n -> Leq (pow (nd 2) (times (nd 2) n)) (times (times (nd 2) n) (B (times (nd 2) n))) .
le_exp_B : n : Nat -> __ : Lt 0 n -> Leq (pow (nd 2) (times (nd 2) n)) (times (times (nd 2) n) (B (times (nd 2) n))) .
le_B_Psi : n : Nat -> Leq (B n) (Psi n) .
let_clause_1033 : n : Nat -> posn : Lt 0 n -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
let_clause_10331 : n : Nat -> posn : Lt 0 n -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
let_clause_10332 : n : Nat -> posn : Lt 0 n -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
let_clause_10333 : n : Nat -> posn : Lt 0 n -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
let_clause_10334 : n : Nat -> posn : Lt 0 n -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
let_clause_10335 : n : Nat -> posn : Lt 0 n -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
le_B_Psi4 : n : Nat -> __ : Lt 0 n -> Leq (times (nd 2) (B (times (nd 4) n))) (Psi (times (nd 4) n)) .
bool_to_nat : _b : bool -> Nat .
bool_to_nat_body : _b : bool -> Nat .
eq_Psi_2_n : n : Nat -> __ : Lt 0 n -> Eq (Psi (times (nd 2) n)) (times (bigop (plus (times (nd 2) n) (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => bigop (log p (times (nd 2) n)) (i : Nat => true) Nat (nd 1) times (i : Nat => pow p (bool_to_nat (leb (plus n (nd 1)) (pow p (plus i (nd 1)))))))) (Psi n)) .
le_Psi_BPsi1 : n : Nat -> __ : Lt 0 n -> Leq (Psi (times (nd 2) n)) (times (B (times (nd 2) n)) (Psi n)) .
le_Psi_BPsi : n : Nat -> Leq (Psi (times (nd 2) n)) (times (B (times (nd 2) n)) (Psi n)) .
le_Psi_exp : n : Nat -> Leq (Psi (times (nd 2) n)) (times (pow (nd 2) (pred (times (nd 2) n))) (Psi n)) .
lt_4_to_le_Psi_exp : n : Nat -> __ : Lt (nd 4) n -> Leq (Psi (times (nd 2) n)) (times (pow (nd 2) (minus (times (nd 2) n) (nd 2))) (Psi n)) .
times_2_pred : n : Nat -> Leq (times (nd 2) (pred n)) (pred (times (nd 2) n)) .
le_S_times_2 : n : Nat -> __ : Lt 0 n -> Leq (plus n (nd 1)) (times (nd 2) n) .
le_Psi_exp1 : n : Nat -> Leq (Psi (pow (nd 2) n)) (pow (nd 2) (minus (times (nd 2) (pow (nd 2) n)) (plus n (nd 2)))) .
monotonic_Psi : monotonic Nat Leq Psi .
Psi_1 : Eq (Psi (nd 1)) (nd 1) .
Psi_2 : Eq (Psi (nd 2)) (nd 2) .
Psi_3 : Eq (Psi (nd 3)) (nd 6) .
Psi_4 : Eq (Psi (nd 4)) (nn 1 (nd 2)) .
let_clause_10336 : n : Nat -> m : Nat -> Hind : (p : Nat -> __ : Lt p m -> __1 : Lt (nd 1) p -> Leq (Psi p) (times (pred p) (pow (nd 2) (minus (times (nd 2) p) (nd 3))))) -> a : Nat -> _clearme : or (Eq m (times (nd 2) a)) (Eq m (plus (times (nd 2) a) (nd 1))) -> Hm : Eq m (plus (times (nd 2) a) (nd 1)) -> Hlt : Lt (nd 1) (plus (times (nd 2) a) (nd 1)) -> Ha : Lt 0 a -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
let_clause_1686 : n : Nat -> m : Nat -> Hind : (p : Nat -> __ : Lt p m -> __1 : Lt (nd 1) p -> Leq (Psi p) (times (pred p) (pow (nd 2) (minus (times (nd 2) p) (nd 3))))) -> a : Nat -> _clearme : or (Eq m (times (nd 2) a)) (Eq m (plus (times (nd 2) a) (nd 1))) -> Hm : Eq m (plus (times (nd 2) a) (nd 1)) -> Hlt : Lt (nd 1) (plus (times (nd 2) a) (nd 1)) -> Ha : Lt 0 a -> Eq (pred m) (plus a a) .
le_Psi_exp4 : n : Nat -> __ : Lt (nd 1) n -> Leq (Psi n) (times (pred n) (pow (nd 2) (minus (times (nd 2) n) (nd 3)))) .
le_n_8_to_le_Psi_exp : n : Nat -> __ : Leq n (nd 8) -> Leq (Psi n) (pow (nd 2) (minus (times (nd 2) n) (nd 3))) .
le_Psi_exp5 : n : Nat -> Leq (Psi n) (pow (nd 2) (minus (times (nd 2) n) (nd 3))) .
le_exp_Psil : n : Nat -> __ : Lt 0 n -> Leq (pow (nd 2) n) (Psi (times (nd 2) n)) .
le_exp_Psi2 : n : Nat -> __ : Lt (nd 1) n -> Leq (pow (nd 2) (div n (nd 2))) (Psi n) .
eq_sigma_pi_SO_n : n : Nat -> Eq (bigop n (i : Nat => true) Nat 0 plus (i : Nat => nd 1)) n .
lePsi_prim : n : Nat -> Leq (pow n (prim n)) (times (Psi n) (bigop (plus n (nd 1)) (p : Nat => primeb p) Nat (nd 1) times (p : Nat => p))) .
le_prim_log : n : Nat -> b : Nat -> __ : Lt (nd 1) b -> Leq (log b (Psi n)) (times (prim n) (plus (log b n) (nd 1))) .
exp_Sn : b : Nat -> n : Nat -> Eq (pow b (plus n (nd 1))) (times b (pow b n)) .
le_exp_priml : n : Nat -> __ : Lt 0 n -> Leq (pow (nd 2) (times (nd 2) n)) (pow (times (nd 2) n) (plus (prim (times (nd 2) n)) (nd 1))) .
le_exp_prim4l : n : Nat -> __ : Lt 0 n -> Leq (pow (nd 2) (plus (times (nd 4) n) (nd 1))) (pow (times (nd 4) n) (plus (prim (times (nd 4) n)) (nd 1))) .
le_priml : n : Nat -> __ : Lt 0 n -> Leq (times (nd 2) n) (times (plus (log (nd 2) (times (nd 2) n)) (nd 1)) (plus (prim (times (nd 2) n)) (nd 1))) .
le_exp_primr : n : Nat -> Leq (pow n (prim n)) (pow (nd 2) (times (nd 2) (minus (times (nd 2) n) (nd 3)))) .
le_primr : n : Nat -> __ : Lt (nd 1) n -> Leq (prim n) (div (times (nd 2) (minus (times (nd 2) n) (nd 3))) (log (nd 2) n)) .
le_priml1 : n : Nat -> __ : Lt 0 n -> Leq (minus (div (times (nd 2) n) (plus (log (nd 2) n) (nd 2))) (nd 1)) (prim (times (nd 2) n)) .
let_clause_1562 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times c n) (times d m)) (nd 1) -> Eq (minus (times n c) (times m d)) (nd 1) .
let_clause_1600 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times c n) (times d m)) (nd 1) -> Eq (gcd m n) (minus (times n c) (times m d)) .
let_clause_15621 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times c n) (times d m)) (nd 1) -> Eq (minus (times n c) (times m d)) (nd 1) .
let_clause_16001 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times c n) (times d m)) (nd 1) -> Eq (gcd m n) (minus (times n c) (times m d)) .
let_clause_1569 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times c n) (times d m)) (nd 1) -> Eq (minus (times n c) (times m d)) (nd 1) .
let_clause_15691 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times c n) (times d m)) (nd 1) -> Eq (minus (times n c) (times m d)) (nd 1) .
let_clause_1575 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times c n) (times d m)) (nd 1) -> x1029 : Nat -> Eq x1029 (times x1029 (minus (times n c) (times m d))) .
let_clause_15692 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (minus (times m d) (times n c)) (nd 1) .
let_clause_1607 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (gcd m n) (minus (times m d) (times n c)) .
let_clause_15622 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (minus (times m d) (times n c)) (nd 1) .
let_clause_16002 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (gcd m n) (minus (times m d) (times n c)) .
let_clause_15623 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (minus (times m d) (times n c)) (nd 1) .
let_clause_16003 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (gcd m n) (minus (times m d) (times n c)) .
let_clause_15624 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (minus (times m d) (times n c)) (nd 1) .
let_clause_16004 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (gcd m n) (minus (times m d) (times n c)) .
let_clause_15625 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (minus (times m d) (times n c)) (nd 1) .
let_clause_16005 : m : Nat -> n : Nat -> a : Nat -> b : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> pnm : Eq (gcd n m) (nd 1) -> c : Nat -> _clearme : ex Nat (d : Nat => or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1))) -> d : Nat -> _clearme0 : or (Eq (minus (times c n) (times d m)) (nd 1)) (Eq (minus (times d m) (times c n)) (nd 1)) -> H : Eq (minus (times d m) (times c n)) (nd 1) -> Eq (gcd m n) (minus (times m d) (times n c)) .
congruent_ab : m : Nat -> n : Nat -> a : Nat -> b : Nat -> __ : Lt 0 n -> __1 : Lt 0 m -> __2 : Eq (gcd n m) (nd 1) -> ex Nat (x : Nat => and (congruent x a m) (congruent x b n)) .
congruent_ab_lt : m : Nat -> n : Nat -> a : Nat -> b : Nat -> __ : Lt 0 n -> __1 : Lt 0 m -> __2 : Eq (gcd n m) (nd 1) -> ex Nat (x : Nat => and (and (congruent x a m) (congruent x b n)) (Lt x (times m n))) .
cr_pair : _n : Nat -> _m : Nat -> _a : Nat -> _b : Nat -> Nat .
cr_pair1 : Eq (cr_pair (nd 2) (nd 3) 0 0) 0 .
cr_pair2 : Eq (cr_pair (nd 2) (nd 3) (nd 1) 0) (nd 3) .
cr_pair3 : Eq (cr_pair (nd 2) (nd 3) (nd 1) (nd 2)) (nd 5) .
cr_pair4 : Eq (cr_pair (nd 5) (nd 7) (nd 3) (nd 2)) (nn 2 (nd 3)) .
cr_pair5 : Eq (cr_pair (nd 3) (nd 7) 0 (nd 4)) (nn 1 (nd 8)) .
mod_cr_pair : m : Nat -> n : Nat -> a : Nat -> b : Nat -> __ : Lt a m -> __1 : Lt b n -> __2 : Eq (gcd n m) (nd 1) -> and (Eq (mod (cr_pair m n a b) m) a) (Eq (mod (cr_pair m n a b) n) b) .
S_mod : _n : Nat -> _m : Nat -> Nat .
congruent : _n : Nat -> _m : Nat -> _p : Nat -> Prop .
congruent_n_n : n : Nat -> p : Nat -> congruent n n p .
transitive_congruent : p : Nat -> transitive Nat (n : Nat => m : Nat => congruent n m p) .
le_to_mod : n : Nat -> m : Nat -> __ : Lt n m -> Eq n (mod n m) .
mod_mod : n : Nat -> p : Nat -> __ : Lt 0 p -> Eq (mod n p) (mod (mod n p) p) .
mod_times_mod : n : Nat -> m : Nat -> p : Nat -> __ : Lt 0 p -> __1 : Lt 0 m -> Eq (mod n p) (mod (mod n (times m p)) p) .
congruent_n_mod_n : n : Nat -> p : Nat -> __ : Lt 0 p -> congruent n (mod n p) p .
congruent_n_mod_times : n : Nat -> m : Nat -> p : Nat -> __ : Lt 0 p -> __1 : Lt 0 m -> congruent n (mod n (times m p)) p .
eq_times_plus_to_congruent : n : Nat -> m : Nat -> p : Nat -> r : Nat -> __ : Lt 0 p -> __1 : Eq n (plus (times r p) m) -> congruent n m p .
divides_to_congruent : n : Nat -> m : Nat -> p : Nat -> __ : Lt 0 p -> __1 : Leq m n -> __2 : divisible p (minus n m) -> congruent n m p .
congruent_to_divides : n : Nat -> m : Nat -> p : Nat -> __ : Lt 0 p -> __1 : congruent n m p -> divisible p (minus n m) .
let_clause_1034 : n : Nat -> m : Nat -> p : Nat -> posp : Lt 0 p -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (mod x2515 x2516) (times x2516 (div x2515 x2516))) .
let_clause_73 : n : Nat -> m : Nat -> p : Nat -> posp : Lt 0 p -> x134 : Nat -> x135 : Nat -> x136 : Nat -> Eq (plus x134 (plus x135 x136)) (plus x135 (plus x134 x136)) .
mod_times : n : Nat -> m : Nat -> p : Nat -> __ : Lt 0 p -> Eq (mod (times n m) p) (mod (times (mod n p) (mod m p)) p) .
congruent_times : n : Nat -> m : Nat -> n1 : Nat -> m1 : Nat -> p : Nat -> __ : Lt 0 p -> __1 : congruent n n1 p -> __2 : congruent m m1 p -> congruent (times n m) (times n1 m1) p .
mod_aux : _p : Nat -> _m : Nat -> _n : Nat -> Nat .
mod_aux_body : _p : Nat -> _m : Nat -> _n : Nat -> Nat .
mod : __ : Nat -> __1 : Nat -> Nat .
div_aux : _p : Nat -> _m : Nat -> _n : Nat -> Nat .
div_aux_body : _p : Nat -> _m : Nat -> _n : Nat -> Nat .
div : __ : Nat -> __1 : Nat -> Nat .
le_mod_aux_m_m : p : Nat -> n : Nat -> m : Nat -> __ : Leq n p -> Leq (mod_aux p n m) m .
lt_mod_m_m : n : Nat -> m : Nat -> __ : Lt 0 m -> Lt (mod n m) m .
div_aux_mod_aux : p : Nat -> n : Nat -> m : Nat -> Eq n (plus (times (div_aux p n m) (plus m (nd 1))) (mod_aux p n m)) .
div_mod : n : Nat -> m : Nat -> Eq n (plus (times (div n m) m) (mod n m)) .
eq_times_div_minus_mod : a : Nat -> b : Nat -> Eq (times (div a b) b) (minus a (mod a b)) .
div_mod_spec : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Prop .
div_mod_spec_intro : n : Nat -> m : Nat -> q : Nat -> r : Nat -> __ : Lt r m -> __1 : Eq n (plus (times q m) r) -> div_mod_spec n m q r .
match_div_mod_spec : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> return_sort : Sort -> return_type : (z : div_mod_spec _n _m _q _r -> return_sort) -> case_div_mod_spec_intro : (__ : Lt _r _m -> __1 : Eq _n (plus (times _q _m) _r) -> return_type (div_mod_spec_intro _n _m _q _r __ __1)) -> z : div_mod_spec _n _m _q _r -> return_type z .
filter_div_mod_spec : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> return_sort : Sort -> return_type : (z : div_mod_spec _n _m _q _r -> return_sort) -> return : (z : div_mod_spec _n _m _q _r -> return_type z) -> z : div_mod_spec _n _m _q _r -> return_type z .
div_mod_spec_ind : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_809 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_811 : Lt _r _m -> x_810 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> x_809 : div_mod_spec _n _m _q _r -> Q_ x_809 .
div_mod_spec_ind_body : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_809 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_811 : Lt _r _m -> x_810 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> x_809 : div_mod_spec _n _m _q _r -> Q_ x_809 .
div_mod_spec_rect_Type4 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_813 : div_mod_spec _n _m _q _r -> Type4) -> _H_div_mod_spec_intro : (x_815 : Lt _r _m -> x_814 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) -> x_813 : div_mod_spec _n _m _q _r -> Q_ x_813 .
div_mod_spec_rect_Type4_body : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_813 : div_mod_spec _n _m _q _r -> Type4) -> _H_div_mod_spec_intro : (x_815 : Lt _r _m -> x_814 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) -> x_813 : div_mod_spec _n _m _q _r -> Q_ x_813 .
div_mod_spec_rect_Type5 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_817 : div_mod_spec _n _m _q _r -> Type5) -> _H_div_mod_spec_intro : (x_819 : Lt _r _m -> x_818 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_819 x_818)) -> x_817 : div_mod_spec _n _m _q _r -> Q_ x_817 .
div_mod_spec_rect_Type5_body : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_817 : div_mod_spec _n _m _q _r -> Type5) -> _H_div_mod_spec_intro : (x_819 : Lt _r _m -> x_818 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_819 x_818)) -> x_817 : div_mod_spec _n _m _q _r -> Q_ x_817 .
div_mod_spec_rect_Type3 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_821 : div_mod_spec _n _m _q _r -> Type3) -> _H_div_mod_spec_intro : (x_823 : Lt _r _m -> x_822 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_823 x_822)) -> x_821 : div_mod_spec _n _m _q _r -> Q_ x_821 .
div_mod_spec_rect_Type3_body : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_821 : div_mod_spec _n _m _q _r -> Type3) -> _H_div_mod_spec_intro : (x_823 : Lt _r _m -> x_822 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_823 x_822)) -> x_821 : div_mod_spec _n _m _q _r -> Q_ x_821 .
div_mod_spec_rect_Type2 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_825 : div_mod_spec _n _m _q _r -> Type2) -> _H_div_mod_spec_intro : (x_827 : Lt _r _m -> x_826 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> x_825 : div_mod_spec _n _m _q _r -> Q_ x_825 .
div_mod_spec_rect_Type2_body : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_825 : div_mod_spec _n _m _q _r -> Type2) -> _H_div_mod_spec_intro : (x_827 : Lt _r _m -> x_826 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> x_825 : div_mod_spec _n _m _q _r -> Q_ x_825 .
div_mod_spec_rect_Type1 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_829 : div_mod_spec _n _m _q _r -> Type1) -> _H_div_mod_spec_intro : (x_831 : Lt _r _m -> x_830 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_831 x_830)) -> x_829 : div_mod_spec _n _m _q _r -> Q_ x_829 .
div_mod_spec_rect_Type1_body : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_829 : div_mod_spec _n _m _q _r -> Type1) -> _H_div_mod_spec_intro : (x_831 : Lt _r _m -> x_830 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_831 x_830)) -> x_829 : div_mod_spec _n _m _q _r -> Q_ x_829 .
div_mod_spec_rect_Type0 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_833 : div_mod_spec _n _m _q _r -> Set) -> _H_div_mod_spec_intro : (x_835 : Lt _r _m -> x_834 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_835 x_834)) -> x_833 : div_mod_spec _n _m _q _r -> Q_ x_833 .
div_mod_spec_rect_Type0_body : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_833 : div_mod_spec _n _m _q _r -> Set) -> _H_div_mod_spec_intro : (x_835 : Lt _r _m -> x_834 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_835 x_834)) -> x_833 : div_mod_spec _n _m _q _r -> Q_ x_833 .
div_mod_spec_rect_CProp4 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_837 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_839 : Lt _r _m -> x_838 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_839 x_838)) -> x_837 : div_mod_spec _n _m _q _r -> Q_ x_837 .
div_mod_spec_rect_CProp4_body : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_837 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_839 : Lt _r _m -> x_838 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_839 x_838)) -> x_837 : div_mod_spec _n _m _q _r -> Q_ x_837 .
div_mod_spec_rect_CProp5 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_841 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_843 : Lt _r _m -> x_842 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_843 x_842)) -> x_841 : div_mod_spec _n _m _q _r -> Q_ x_841 .
div_mod_spec_rect_CProp5_body : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_841 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_843 : Lt _r _m -> x_842 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_843 x_842)) -> x_841 : div_mod_spec _n _m _q _r -> Q_ x_841 .
div_mod_spec_rect_CProp3 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_845 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_847 : Lt _r _m -> x_846 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_847 x_846)) -> x_845 : div_mod_spec _n _m _q _r -> Q_ x_845 .
div_mod_spec_rect_CProp3_body : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_845 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_847 : Lt _r _m -> x_846 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_847 x_846)) -> x_845 : div_mod_spec _n _m _q _r -> Q_ x_845 .
div_mod_spec_rect_CProp2 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_849 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_851 : Lt _r _m -> x_850 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_851 x_850)) -> x_849 : div_mod_spec _n _m _q _r -> Q_ x_849 .
div_mod_spec_rect_CProp2_body : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_849 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_851 : Lt _r _m -> x_850 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_851 x_850)) -> x_849 : div_mod_spec _n _m _q _r -> Q_ x_849 .
div_mod_spec_rect_CProp1 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_853 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_855 : Lt _r _m -> x_854 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_855 x_854)) -> x_853 : div_mod_spec _n _m _q _r -> Q_ x_853 .
div_mod_spec_rect_CProp1_body : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_853 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_855 : Lt _r _m -> x_854 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_855 x_854)) -> x_853 : div_mod_spec _n _m _q _r -> Q_ x_853 .
div_mod_spec_rect_CProp0 : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_857 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_859 : Lt _r _m -> x_858 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_859 x_858)) -> x_857 : div_mod_spec _n _m _q _r -> Q_ x_857 .
div_mod_spec_rect_CProp0_body : _n : Nat -> _m : Nat -> _q : Nat -> _r : Nat -> Q_ : (_x_857 : div_mod_spec _n _m _q _r -> Prop) -> _H_div_mod_spec_intro : (x_859 : Lt _r _m -> x_858 : Eq _n (plus (times _q _m) _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_859 x_858)) -> x_857 : div_mod_spec _n _m _q _r -> Q_ x_857 .
div_mod_spec_inv_ind : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1434 : div_mod_spec x1 x2 x3 x4 -> Prop) -> _H1 : (x_811 : Lt x4 x2 -> x_810 : Eq x1 (plus (times x3 x2) x4) -> _z1435 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810) -> P (div_mod_spec_intro x1 x2 x3 x4 x_811 x_810)) -> P Hterm .
div_mod_spec_inv_rect_Type4 : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1440 : div_mod_spec x1 x2 x3 x4 -> Type4) -> _H1 : (x_815 : Lt x4 x2 -> x_814 : Eq x1 (plus (times x3 x2) x4) -> _z1441 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_815 x_814) -> P (div_mod_spec_intro x1 x2 x3 x4 x_815 x_814)) -> P Hterm .
div_mod_spec_inv_rect_Type3 : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1446 : div_mod_spec x1 x2 x3 x4 -> Type3) -> _H1 : (x_823 : Lt x4 x2 -> x_822 : Eq x1 (plus (times x3 x2) x4) -> _z1447 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822) -> P (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822)) -> P Hterm .
div_mod_spec_inv_rect_Type2 : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1452 : div_mod_spec x1 x2 x3 x4 -> Type2) -> _H1 : (x_827 : Lt x4 x2 -> x_826 : Eq x1 (plus (times x3 x2) x4) -> _z1453 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_827 x_826) -> P (div_mod_spec_intro x1 x2 x3 x4 x_827 x_826)) -> P Hterm .
div_mod_spec_inv_rect_Type1 : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1458 : div_mod_spec x1 x2 x3 x4 -> Type1) -> _H1 : (x_831 : Lt x4 x2 -> x_830 : Eq x1 (plus (times x3 x2) x4) -> _z1459 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_831 x_830) -> P (div_mod_spec_intro x1 x2 x3 x4 x_831 x_830)) -> P Hterm .
div_mod_spec_inv_rect_Type0 : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1464 : div_mod_spec x1 x2 x3 x4 -> Set) -> _H1 : (x_835 : Lt x4 x2 -> x_834 : Eq x1 (plus (times x3 x2) x4) -> _z1465 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_835 x_834) -> P (div_mod_spec_intro x1 x2 x3 x4 x_835 x_834)) -> P Hterm .
div_mod_spec_inv_rect_CProp4 : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1470 : div_mod_spec x1 x2 x3 x4 -> Prop) -> _H1 : (x_839 : Lt x4 x2 -> x_838 : Eq x1 (plus (times x3 x2) x4) -> _z1471 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_839 x_838) -> P (div_mod_spec_intro x1 x2 x3 x4 x_839 x_838)) -> P Hterm .
div_mod_spec_inv_rect_CProp3 : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1476 : div_mod_spec x1 x2 x3 x4 -> Prop) -> _H1 : (x_847 : Lt x4 x2 -> x_846 : Eq x1 (plus (times x3 x2) x4) -> _z1477 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_847 x_846) -> P (div_mod_spec_intro x1 x2 x3 x4 x_847 x_846)) -> P Hterm .
div_mod_spec_inv_rect_CProp2 : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1482 : div_mod_spec x1 x2 x3 x4 -> Prop) -> _H1 : (x_851 : Lt x4 x2 -> x_850 : Eq x1 (plus (times x3 x2) x4) -> _z1483 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_851 x_850) -> P (div_mod_spec_intro x1 x2 x3 x4 x_851 x_850)) -> P Hterm .
div_mod_spec_inv_rect_CProp1 : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1488 : div_mod_spec x1 x2 x3 x4 -> Prop) -> _H1 : (x_855 : Lt x4 x2 -> x_854 : Eq x1 (plus (times x3 x2) x4) -> _z1489 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854) -> P (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P Hterm .
div_mod_spec_inv_rect_CProp0 : x1 : Nat -> x2 : Nat -> x3 : Nat -> x4 : Nat -> Hterm : div_mod_spec x1 x2 x3 x4 -> P : (_z1494 : div_mod_spec x1 x2 x3 x4 -> Prop) -> _H1 : (x_859 : Lt x4 x2 -> x_858 : Eq x1 (plus (times x3 x2) x4) -> _z1495 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858) -> P (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> P Hterm .
div_mod_spec_discr : a1 : Nat -> a2 : Nat -> a3 : Nat -> a4 : Nat -> x : div_mod_spec a1 a2 a3 a4 -> y : div_mod_spec a1 a2 a3 a4 -> _e : Eq x y -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 (nd 1)) (__ : div_mod_spec a1 a2 a3 a4 => univ Type2) (t0 : Lt a4 a2 => t1 : Eq a1 (plus (times a3 a2) a4) => match_div_mod_spec a1 a2 a3 a4 (plus Type2 (nd 1)) (__ : div_mod_spec a1 a2 a3 a4 => univ Type2) (u0 : Lt a4 a2 => u1 : Eq a1 (plus (times a3 a2) a4) => prod (plus Type1 (nd 1)) Type1 (univ Type1) (P : Type1 => prod Type1 Type1 (prod Prop Type1 (Eq (R0 (Lt a4 a2) t0) u0) (e0 : Eq (R0 (Lt a4 a2) t0) u0 => prod Prop Type1 (Eq (R1 (Lt a4 a2) t0 (x_19 : Lt a4 a2 => _x_20 : Eq t0 x_19 => (x0 : Lt a4 a2 => p0 : Eq t0 x0 => Eq a1 (plus (times a3 a2) a4)) x_19 _x_20) t1 u0 e0) u1) (_e1 : Eq (R1 (Lt a4 a2) t0 (x_19 : Lt a4 a2 => _x_20 : Eq t0 x_19 => (x0 : Lt a4 a2 => p0 : Eq t0 x0 => Eq a1 (plus (times a3 a2) a4)) x_19 _x_20) t1 u0 e0) u1 => P))) (_z53 : (e0 : Eq (R0 (Lt a4 a2) t0) u0 -> _e1 : Eq (R1 (Lt a4 a2) t0 (x_19 : Lt a4 a2 => _x_20 : Eq t0 x_19 => (x0 : Lt a4 a2 => p0 : Eq t0 x0 => Eq a1 (plus (times a3 a2) a4)) x_19 _x_20) t1 u0 e0) u1 -> P) => P))) y) x .
div_mod_spec_to_not_eq_O : n : Nat -> m : Nat -> q : Nat -> r : Nat -> __ : div_mod_spec n m q r -> not (Eq m 0) .
div_mod_spec_div_mod : n : Nat -> m : Nat -> __ : Lt 0 m -> div_mod_spec n m (div n m) (mod n m) .
let_clause_1078 : a : Nat -> b : Nat -> q : Nat -> r : Nat -> q1 : Nat -> r1 : Nat -> _clearme : div_mod_spec a b q r -> ltrb : Lt r b -> spec : Eq a (plus (times q b) r) -> _clearme0 : div_mod_spec a b q1 r1 -> ltr1b : Lt r1 b -> spec1 : Eq a (plus (times q1 b) r1) -> leqq1 : Leq q q1 -> ltqq1 : Lt q q1 -> Eq a (plus r (times b q)) .
let_clause_1062 : a : Nat -> b : Nat -> q : Nat -> r : Nat -> q1 : Nat -> r1 : Nat -> _clearme : div_mod_spec a b q r -> ltrb : Lt r b -> spec : Eq a (plus (times q b) r) -> _clearme0 : div_mod_spec a b q1 r1 -> ltr1b : Lt r1 b -> spec1 : Eq a (plus (times q1 b) r1) -> leqq1 : not (Leq q q1) -> Eq a (plus r1 (times b q1)) .
div_mod_spec_to_eq : a : Nat -> b : Nat -> q : Nat -> r : Nat -> q1 : Nat -> r1 : Nat -> __ : div_mod_spec a b q r -> __1 : div_mod_spec a b q1 r1 -> Eq q q1 .
div_mod_spec_to_eq2 : a : Nat -> b : Nat -> q : Nat -> r : Nat -> q1 : Nat -> r1 : Nat -> __ : div_mod_spec a b q r -> __1 : div_mod_spec a b q1 r1 -> Eq r r1 .
div_plus_times : m : Nat -> q : Nat -> r : Nat -> __ : Lt r m -> Eq (div (plus (times q m) r) m) q .
mod_plus_times : m : Nat -> q : Nat -> r : Nat -> __ : Lt r m -> Eq (mod (plus (times q m) r) m) r .
div_times : a : Nat -> b : Nat -> __ : Lt 0 b -> Eq (div (times a b) b) a .
div_n_n : n : Nat -> __ : Lt 0 n -> Eq (div n n) (nd 1) .
eq_div_O : n : Nat -> m : Nat -> __ : Lt n m -> Eq (div n m) 0 .
mod_n_n : n : Nat -> __ : Lt 0 n -> Eq (mod n n) 0 .
mod_S : n : Nat -> m : Nat -> __ : Lt 0 m -> __1 : Lt (plus (mod n m) (nd 1)) m -> Eq (mod (plus n (nd 1)) m) (plus (mod n m) (nd 1)) .
mod_O_n : n : Nat -> Eq (mod 0 n) 0 .
lt_to_eq_mod : n : Nat -> m : Nat -> __ : Lt n m -> Eq (mod n m) n .
or_div_mod : n : Nat -> q : Nat -> __ : Lt 0 q -> or (and (Eq (plus (mod n q) (nd 1)) q) (Eq (plus n (nd 1)) (times (plus (div n q) (nd 1)) q))) (and (Lt (plus (mod n q) (nd 1)) q) (Eq (plus n (nd 1)) (plus (times (div n q) q) (plus (mod n q) (nd 1))))) .
injective_times_r : n : Nat -> __ : Lt 0 n -> injectif Nat Nat (m : Nat => times n m) .
injective_times_l : n : Nat -> __ : Lt 0 n -> injectif Nat Nat (m : Nat => times m n) .
lt_div_S : n : Nat -> m : Nat -> __ : Lt 0 m -> Lt n (times (plus (div n m) (nd 1)) m) .
le_div : n : Nat -> m : Nat -> __ : Lt 0 n -> Leq (div m n) m .
le_plus_mod : m : Nat -> n : Nat -> q : Nat -> __ : Lt 0 q -> Leq (mod (plus m n) q) (plus (mod m q) (mod n q)) .
le_plus_div : m : Nat -> n : Nat -> q : Nat -> __ : Lt 0 q -> Leq (plus (div m q) (div n q)) (div (plus m n) q) .
le_times_to_le_div : a : Nat -> b : Nat -> c : Nat -> __ : Lt 0 b -> __1 : Leq (times b c) a -> Leq c (div a b) .
le_times_to_le_div2 : m : Nat -> n : Nat -> q : Nat -> __ : Lt 0 q -> __1 : Leq n (times m q) -> Leq (div n q) m .
lt_times_to_lt_div : m : Nat -> n : Nat -> q : Nat -> __ : Lt n (times m q) -> Lt (div n q) m .
le_div_S_S_div : n : Nat -> m : Nat -> __ : Lt 0 m -> Leq (div (plus n (nd 1)) m) (plus (div n m) (nd 1)) .
le_times_div_div_times : a : Nat -> n : Nat -> m : Nat -> __ : Lt 0 m -> Leq (times a (div n m)) (div (times a n) m) .
monotonic_div : n : Nat -> __ : Lt 0 n -> monotonic Nat Leq (m : Nat => div m n) .
pos_div : n : Nat -> m : Nat -> __ : Lt 0 m -> __1 : Lt 0 n -> __2 : Eq (mod n m) 0 -> Lt 0 (div n m) .
let_clause_1034 : n : Nat -> m : Nat -> q : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (mod x2515 x2516) (times x2516 (div x2515 x2516))) .
eq_div_div_div_times : n : Nat -> m : Nat -> q : Nat -> __ : Lt 0 n -> __1 : Lt 0 m -> Eq (div (div q n) m) (div q (times n m)) .
eq_div_div_div_div : n : Nat -> m : Nat -> q : Nat -> __ : Lt 0 n -> __1 : Lt 0 m -> Eq (div (div q n) m) (div (div q m) n) .
lt_to_le_times_to_lt_S_to_div : a : Nat -> c : Nat -> b : Nat -> __ : Lt 0 b -> __1 : Leq (times b c) a -> __2 : Lt a (times b (plus c (nd 1))) -> Eq (div a b) c .
div_times_times : a : Nat -> b : Nat -> c : Nat -> __ : Lt 0 c -> __1 : Lt 0 b -> Eq (div a b) (div (times a c) (times b c)) .
times_mod : a : Nat -> b : Nat -> c : Nat -> __ : Lt 0 c -> __1 : Lt 0 b -> Eq (mod (times a c) (times b c)) (times c (mod a b)) .
le_div_times_m : a : Nat -> i : Nat -> m : Nat -> __ : Lt 0 i -> __1 : Lt 0 m -> Leq (div (times a (div m i)) m) (div a i) .
pow : __ : Nat -> __1 : Nat -> Nat .
exp_body : __ : Nat -> __1 : Nat -> Nat .
exp_plus_times : n : Nat -> p : Nat -> q : Nat -> Eq (pow n (plus p q)) (times (pow n p) (pow n q)) .
exp_n_O : n : Nat -> Eq (nd 1) (pow n 0) .
exp_n_1 : n : Nat -> Eq n (pow n (nd 1)) .
exp_1_n : n : Nat -> Eq (nd 1) (pow (nd 1) n) .
exp_2 : n : Nat -> Eq (pow n (nd 2)) (times n n) .
exp_exp_times : n : Nat -> p : Nat -> q : Nat -> Eq (pow (pow n p) q) (pow n (times p q)) .
lt_O_exp : n : Nat -> m : Nat -> __ : Lt 0 n -> Lt 0 (pow n m) .
lt_m_exp_nm : n : Nat -> m : Nat -> __ : Lt (nd 1) n -> Lt m (pow n m) .
exp_to_eq_O : n : Nat -> m : Nat -> __ : Lt (nd 1) n -> __1 : Eq (pow n m) (nd 1) -> Eq m 0 .
let_clause_1258 : b : Nat -> lt1b : Lt (nd 1) b -> n : Nat -> H : Eq (times (pow b n) b) (nd 1) -> Eq (times b (pow b n)) (nd 1) .
injective_exp_r : b : Nat -> __ : Lt (nd 1) b -> injectif Nat Nat (i : Nat => pow b i) .
le_exp : n : Nat -> m : Nat -> p : Nat -> __ : Lt 0 p -> __1 : Leq n m -> Leq (pow p n) (pow p m) .
le_exp1 : n : Nat -> m : Nat -> a : Nat -> __ : Lt 0 a -> __1 : Leq n m -> Leq (pow n a) (pow m a) .
lt_exp : n : Nat -> m : Nat -> p : Nat -> __ : Lt (nd 1) p -> __1 : Lt n m -> Lt (pow p n) (pow p m) .
lt_exp1 : n : Nat -> m : Nat -> p : Nat -> __ : Lt 0 p -> __1 : Lt n m -> Lt (pow n p) (pow m p) .
le_exp_to_le : b : Nat -> n : Nat -> m : Nat -> __ : Lt (nd 1) b -> __1 : Leq (pow b n) (pow b m) -> Leq n m .
le_exp_to_le1 : n : Nat -> m : Nat -> p : Nat -> __ : Lt 0 p -> __1 : Leq (pow n p) (pow m p) -> Leq n m .
lt_exp_to_lt : a : Nat -> n : Nat -> m : Nat -> __ : Lt 0 a -> __1 : Lt (pow a n) (pow a m) -> Lt n m .
lt_exp_to_lt1 : a : Nat -> n : Nat -> m : Nat -> __ : Lt 0 a -> __1 : Lt (pow n a) (pow m a) -> Lt n m .
times_exp : n : Nat -> m : Nat -> p : Nat -> Eq (times (pow n p) (pow m p)) (pow (times n m) p) .
factorial : __ : Nat -> Nat .
fact_body : __ : Nat -> Nat .
factS : n : Nat -> Eq (factorial (plus n (nd 1))) (times (plus n (nd 1)) (factorial n)) .
le_1_fact : n : Nat -> Leq (nd 1) (factorial n) .
le_2_fact : n : Nat -> __ : Lt (nd 1) n -> Leq (nd 2) (factorial n) .
le_n_fact_n : n : Nat -> Leq n (factorial n) .
let_clause_16 : n : Nat -> m : Nat -> lt2 : Lt (nd 2) (plus m (nd 1)) -> x32 : Nat -> Eq (plus x32 (nd 1)) (plus x32 (nd 1)) .
lt_n_fact_n : n : Nat -> __ : Lt (nd 2) n -> Lt n (factorial n) .
fact_to_exp1 : n : Nat -> __ : Lt 0 n -> Leq (factorial (times (nd 2) n)) (times (times (pow (nd 2) (pred (times (nd 2) n))) (factorial n)) (factorial n)) .
fact_to_exp : n : Nat -> Leq (factorial (times (nd 2) n)) (times (times (pow (nd 2) (pred (times (nd 2) n))) (factorial n)) (factorial n)) .
exp_to_fact1 : n : Nat -> __ : Lt 0 n -> Lt (times (times (pow (nd 2) (times (nd 2) n)) (factorial n)) (factorial n)) (factorial (plus (times (nd 2) n) (nd 1))) .
exp_to_fact2 : n : Nat -> __ : Lt 0 n -> Leq (times (pow (nd 2) (times (nd 2) n)) (pow (factorial n) (nd 2))) (times (times (nd 2) n) (factorial (times (nd 2) n))) .
le_fact_10 : Leq (factorial (times (nd 2) (nd 5))) (times (times (pow (nd 2) (minus (times (nd 2) (nd 5)) (nd 2))) (factorial (nd 5))) (factorial (nd 5))) .
ab_times_cd : a : Nat -> b : Nat -> c : Nat -> d : Nat -> Eq (times (times a b) (times c d)) (times (times a c) (times b d)) .
lt_4_to_fact : n : Nat -> __ : Lt (nd 4) n -> Leq (factorial (times (nd 2) n)) (times (times (pow (nd 2) (minus (times (nd 2) n) (nd 2))) (factorial n)) (factorial n)) .
permut_S_mod : n : Nat -> permut (S_mod (plus n (nd 1))) n .
prime_to_not_divides_fact : p : Nat -> __ : prime p -> n : Nat -> __1 : Lt n p -> not (divisible p (factorial n)) .
permut_mod : p : Nat -> a : Nat -> __ : prime p -> __1 : not (divisible p a) -> permut (n : Nat => mod (times a n) p) (pred p) .
eq_fact_pi_p : n : Nat -> Eq (factorial n) (bigop (minus (plus n (nd 1)) (nd 1)) (i : Nat => (i0 : Nat => true) (plus i (nd 1))) Nat (nd 1) times (i : Nat => (i0 : Nat => i0) (plus i (nd 1)))) .
congruent_pi : f : (__ : Nat -> Nat) -> n : Nat -> p : Nat -> __ : Lt 0 p -> congruent (bigop n (i : Nat => true) Nat (nd 1) times (i : Nat => f i)) (bigop n (i : Nat => true) Nat (nd 1) times (i : Nat => mod (f i) p)) p .
congruent_exp_pred_SO : p : Nat -> a : Nat -> __ : prime p -> __1 : not (divisible p a) -> congruent (pow a (pred p)) (nd 1) p .
gcd_aux : _p : Nat -> _m : Nat -> _n : Nat -> Nat .
gcd_aux_body : _p : Nat -> _m : Nat -> _n : Nat -> Nat .
gcd : __ : Nat -> __1 : Nat -> Nat .
commutative_gcd : n : Nat -> m : Nat -> Eq (gcd n m) (gcd m n) .
gcd_O_l : m : Nat -> Eq (gcd 0 m) m .
divides_mod : p : Nat -> m : Nat -> n : Nat -> __ : Lt 0 n -> __1 : divisible p m -> __2 : divisible p n -> divisible p (mod m n) .
divides_mod_to_divides : p : Nat -> m : Nat -> n : Nat -> __ : Lt 0 n -> __1 : divisible p (mod m n) -> __2 : divisible p n -> divisible p m .
divides_to_gcd_aux : p : Nat -> m : Nat -> n : Nat -> __ : Lt 0 p -> __1 : Lt 0 n -> __2 : divisible n m -> Eq (gcd_aux p m n) n .
divides_to_gcd : m : Nat -> n : Nat -> __ : Lt 0 n -> __1 : divisible n m -> Eq (gcd n m) n .
not_divides_to_gcd_aux : p : Nat -> m : Nat -> n : Nat -> __ : Lt 0 n -> __1 : not (divisible n m) -> Eq (gcd_aux (plus p (nd 1)) m n) (gcd_aux p n (mod m n)) .
divides_gcd_aux_mn : p : Nat -> m : Nat -> n : Nat -> __ : Lt 0 n -> __1 : Leq n m -> __2 : Leq n p -> and (divisible (gcd_aux p m n) m) (divisible (gcd_aux p m n) n) .
divides_gcd_nm : n : Nat -> m : Nat -> and (divisible (gcd n m) m) (divisible (gcd n m) n) .
divides_gcd_l : n : Nat -> m : Nat -> divisible (gcd n m) n .
divides_gcd_r : n : Nat -> m : Nat -> divisible (gcd n m) m .
divides_times_gcd_aux : p : Nat -> m : Nat -> n : Nat -> d : Nat -> c : Nat -> __ : Lt 0 c -> __1 : Lt 0 n -> __2 : Leq n m -> __3 : Leq n p -> __4 : divisible d (times c m) -> __5 : divisible d (times c n) -> divisible d (times c (gcd_aux p m n)) .
divides_gcd_aux : p : Nat -> m : Nat -> n : Nat -> d : Nat -> __ : Lt 0 n -> __1 : Leq n m -> __2 : Leq n p -> __3 : divisible d m -> __4 : divisible d n -> divisible d (gcd_aux p m n) .
divides_d_times_gcd : m : Nat -> n : Nat -> d : Nat -> c : Nat -> __ : Lt 0 c -> __1 : divisible d (times c m) -> __2 : divisible d (times c n) -> divisible d (times c (gcd n m)) .
divides_d_gcd : m : Nat -> n : Nat -> d : Nat -> __ : divisible d m -> __1 : divisible d n -> divisible d (gcd n m) .
let_clause_1544 : p : Nat -> q : Nat -> Hind : (m : Nat -> n : Nat -> __ : Lt 0 n -> __1 : Leq n m -> __2 : Leq n q -> ex Nat (a : Nat => ex Nat (b : Nat => or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> m : Nat -> n : Nat -> posn : Lt 0 n -> lenm : Leq n m -> lenS : Leq n (plus q (nd 1)) -> ndivnm : not (divisible n m) -> a : Nat -> _clearme : ex Nat (b : Nat => or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> b : Nat -> _clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n)) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n)) .
let_clause_15441 : p : Nat -> q : Nat -> Hind : (m : Nat -> n : Nat -> __ : Lt 0 n -> __1 : Leq n m -> __2 : Leq n q -> ex Nat (a : Nat => ex Nat (b : Nat => or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> m : Nat -> n : Nat -> posn : Lt 0 n -> lenm : Leq n m -> lenS : Leq n (plus q (nd 1)) -> ndivnm : not (divisible n m) -> a : Nat -> _clearme : ex Nat (b : Nat => or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> b : Nat -> _clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n)) .
eq_minus_gcd_aux : p : Nat -> m : Nat -> n : Nat -> __ : Lt 0 n -> __1 : Leq n m -> __2 : Leq n p -> ex Nat (a : Nat => ex Nat (b : Nat => or (Eq (minus (times a n) (times b m)) (gcd_aux p m n)) (Eq (minus (times b m) (times a n)) (gcd_aux p m n)))) .
let_clause_1549 : m : Nat -> n : Nat -> posn : Lt 0 n -> eqm0 : Eq 0 m -> x1106 : Nat -> Eq x1106 (minus x1106 m) .
let_clause_15491 : m : Nat -> n : Nat -> eqn0 : Eq 0 n -> x1106 : Nat -> Eq x1106 (minus x1106 n) .
let_clause_1551 : m : Nat -> n : Nat -> eqn0 : Eq 0 n -> x347 : Nat -> Eq n (times x347 n) .
eq_minus_gcd : m : Nat -> n : Nat -> ex Nat (a : Nat => ex Nat (b : Nat => or (Eq (minus (times a n) (times b m)) (gcd n m)) (Eq (minus (times b m) (times a n)) (gcd n m)))) .
let_clause_1545 : m : Nat -> n : Nat -> H : Eq (gcd m n) 0 -> _clearme : divisible 0 n -> q1 : Nat -> H1 : Eq n (times 0 q1) -> _clearme0 : divisible 0 m -> q2 : Nat -> H2 : Eq m (times 0 q2) -> Eq m 0 .
gcd_O_to_eq_O : m : Nat -> n : Nat -> __ : Eq (gcd m n) 0 -> and (Eq m 0) (Eq n 0) .
let_clause_1571 : m : Nat -> n : Nat -> posn : Lt 0 n -> H : Eq (gcd m n) 0 -> auto : Eq m 0 -> auto' : Eq n 0 -> Eq m n .
let_clause_1572 : m : Nat -> n : Nat -> posn : Lt 0 n -> H : Eq (gcd m n) 0 -> auto : Eq m 0 -> auto' : Eq n 0 -> Eq m 0 .
lt_O_gcd : m : Nat -> n : Nat -> __ : Lt 0 n -> Lt 0 (gcd m n) .
gcd_n_n : n : Nat -> Eq (gcd n n) n .
gcd_1_to_lt_O : i : Nat -> n : Nat -> __ : Lt (nd 1) n -> __1 : Eq (gcd i n) (nd 1) -> Lt 0 i .
gcd_1_to_lt_n : i : Nat -> n : Nat -> __ : Lt (nd 1) n -> __1 : Leq i n -> __2 : Eq (gcd i n) (nd 1) -> Lt i n .
gcd_n_times_nm : n : Nat -> m : Nat -> __ : Lt 0 m -> Eq (gcd n (times n m)) n .
le_gcd_times : m : Nat -> n : Nat -> p : Nat -> __ : Lt 0 p -> Leq (gcd m n) (gcd m (times n p)) .
gcd_times_SO_to_gcd_SO : m : Nat -> n : Nat -> p : Nat -> __ : Lt 0 n -> __1 : Lt 0 p -> __2 : Eq (gcd m (times n p)) (nd 1) -> Eq (gcd m n) (nd 1) .
eq_gcd_SO_to_not_divides : n : Nat -> m : Nat -> __ : Lt (nd 1) n -> __1 : Eq (gcd n m) (nd 1) -> not (divisible n m) .
gcd_SO_n : n : Nat -> Eq (gcd (nd 1) n) (nd 1) .
divides_gcd_mod : m : Nat -> n : Nat -> __ : Lt 0 n -> divisible (gcd m n) (gcd n (mod m n)) .
divides_mod_gcd : m : Nat -> n : Nat -> __ : Lt 0 n -> divisible (gcd n (mod m n)) (gcd m n) .
gcd_mod : m : Nat -> n : Nat -> __ : Lt 0 n -> Eq (gcd n (mod m n)) (gcd m n) .
prime_to_gcd_1 : n : Nat -> m : Nat -> __ : prime n -> __1 : not (divisible n m) -> Eq (gcd n m) (nd 1) .
divides_times_to_divides : p : Nat -> n : Nat -> m : Nat -> __ : prime p -> __1 : divisible p (times n m) -> or (divisible p n) (divisible p m) .
divides_exp_to_divides : p : Nat -> n : Nat -> m : Nat -> __ : prime p -> __1 : divisible p (pow n m) -> divisible p n .
divides_exp_to_eq : p : Nat -> q : Nat -> m : Nat -> __ : prime p -> __1 : prime q -> __2 : divisible p (pow q m) -> Eq p q .
let_clause_1595 : p : Nat -> n : Nat -> m : Nat -> posn : Lt 0 n -> posm : Lt 0 m -> primepn : Eq (gcd p n) (nd 1) -> primepm : Eq (gcd p m) (nd 1) -> lt1gcd : Lt (nd 1) (gcd p (times n m)) -> H : divisible (smallest_factor (gcd p (times n m))) m -> Eq (gcd p n) (gcd p m) .
eq_gcd_times_1 : p : Nat -> n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : Lt 0 m -> __2 : Eq (gcd p n) (nd 1) -> __3 : Eq (gcd p m) (nd 1) -> Eq (gcd p (times n m)) (nd 1) .
let_clause_1561 : p : Nat -> m : Nat -> n : Nat -> posn : Lt 0 p -> gcd1 : Eq (gcd p m) (nd 1) -> _clearme : divisible p (times m n) -> c : Nat -> nm : Eq (times m n) (times p c) -> a : Nat -> _clearme0 : ex Nat (b : Nat => or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> b : Nat -> _clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)) -> H : Eq (minus (times a p) (times b m)) (gcd p m) -> H0 : Eq (minus (times a p) (times b m)) (nd 1) -> Eq (minus (times p a) (times m b)) (nd 1) .
let_clause_1617 : p : Nat -> m : Nat -> n : Nat -> posn : Lt 0 p -> gcd1 : Eq (gcd p m) (nd 1) -> _clearme : divisible p (times m n) -> c : Nat -> nm : Eq (times m n) (times p c) -> a : Nat -> _clearme0 : ex Nat (b : Nat => or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> b : Nat -> _clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)) -> H : Eq (minus (times a p) (times b m)) (gcd p m) -> H0 : Eq (minus (times a p) (times b m)) (nd 1) -> Eq (gcd p m) (minus (times p a) (times m b)) .
let_clause_15611 : p : Nat -> m : Nat -> n : Nat -> posn : Lt 0 p -> gcd1 : Eq (gcd p m) (nd 1) -> _clearme : divisible p (times m n) -> c : Nat -> nm : Eq (times m n) (times p c) -> a : Nat -> _clearme0 : ex Nat (b : Nat => or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> b : Nat -> _clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)) -> H : Eq (minus (times b m) (times a p)) (gcd p m) -> H0 : Eq (minus (times b m) (times a p)) (nd 1) -> Eq (minus (times m b) (times p a)) (nd 1) .
let_clause_16171 : p : Nat -> m : Nat -> n : Nat -> posn : Lt 0 p -> gcd1 : Eq (gcd p m) (nd 1) -> _clearme : divisible p (times m n) -> c : Nat -> nm : Eq (times m n) (times p c) -> a : Nat -> _clearme0 : ex Nat (b : Nat => or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> b : Nat -> _clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)) -> H : Eq (minus (times b m) (times a p)) (gcd p m) -> H0 : Eq (minus (times b m) (times a p)) (nd 1) -> Eq (gcd p m) (minus (times m b) (times p a)) .
gcd_1_to_divides_times_to_divides : p : Nat -> n : Nat -> m : Nat -> __ : Lt 0 p -> __1 : Eq (gcd p n) (nd 1) -> __2 : divisible p (times n m) -> divisible p m .
divides_to_divides_times : p : Nat -> q : Nat -> n : Nat -> __ : prime p -> __1 : not (divisible p q) -> __2 : divisible p n -> __3 : divisible q n -> divisible (times p q) n .
iter : H : Set -> __ : (__ : H -> H) -> __1 : Nat -> __2 : H -> H .
iter_body : H : Set -> __ : (__ : H -> H) -> __1 : Nat -> __2 : H -> H .
le_iter : g : (__ : Nat -> Nat) -> a : Nat -> __ : (x : Nat -> Leq x (g x)) -> i : Nat -> Leq a (iter Nat g i a) .
iter_iter : A : Set -> g : (__ : A -> A) -> a : A -> b : Nat -> c : Nat -> Eq (iter A g c (iter A g b a)) (iter A g (plus b c) a) .
monotonic_iter : g : (__ : Nat -> Nat) -> a : Nat -> b : Nat -> i : Nat -> __ : monotonic Nat Leq g -> __1 : Leq a b -> Leq (iter Nat g i a) (iter Nat g i b) .
monotonic_iter2 : g : (__ : Nat -> Nat) -> a : Nat -> i : Nat -> j : Nat -> __ : (x : Nat -> Leq x (g x)) -> __1 : Leq i j -> Leq (iter Nat g i a) (iter Nat g j a) .
log : _p : Nat -> _n : Nat -> Nat .
tech_log : p : Nat -> n : Nat -> __ : Lt (nd 1) p -> __1 : Lt 0 n -> Eq (log p n) (max (plus n (nd 1)) (x : Nat => leb (pow p x) n)) .
le_exp_log : p : Nat -> n : Nat -> __ : Lt 0 n -> Leq (pow p (log p n)) n .
log_SO : n : Nat -> __ : Lt (nd 1) n -> Eq (log n (nd 1)) 0 .
lt_to_log_O : n : Nat -> m : Nat -> __ : Lt 0 m -> __1 : Lt m n -> Eq (log n m) 0 .
lt_log_n_n : p : Nat -> n : Nat -> __ : Lt (nd 1) p -> __1 : Lt 0 n -> Lt (log p n) n .
lt_O_log : p : Nat -> n : Nat -> __ : Lt (nd 1) n -> __1 : Leq p n -> Lt 0 (log p n) .
le_log_n_n : p : Nat -> n : Nat -> __ : Lt (nd 1) p -> Leq (log p n) n .
let_clause_1033 : p : Nat -> n : Nat -> lt1p : Lt (nd 1) p -> m : Nat -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
lt_exp_log : p : Nat -> n : Nat -> __ : Lt (nd 1) p -> Lt n (pow p (plus (log p n) (nd 1))) .
log_times1 : p : Nat -> n : Nat -> m : Nat -> __ : Lt (nd 1) p -> __1 : Lt 0 n -> __2 : Lt 0 m -> Leq (log p (times n m)) (plus (plus (log p n) (log p m)) (nd 1)) .
log_times : p : Nat -> n : Nat -> m : Nat -> __ : Lt (nd 1) p -> Leq (log p (times n m)) (plus (plus (log p n) (log p m)) (nd 1)) .
log_times_l : p : Nat -> n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : Lt 0 m -> __2 : Lt (nd 1) p -> Leq (plus (log p n) (log p m)) (log p (times n m)) .
log_exp : p : Nat -> n : Nat -> m : Nat -> __ : Lt (nd 1) p -> __1 : Lt 0 m -> Eq (log p (times (pow p n) m)) (plus n (log p m)) .
eq_log_exp : p : Nat -> n : Nat -> __ : Lt (nd 1) p -> Eq (log p (pow p n)) n .
log_exp1 : p : Nat -> n : Nat -> m : Nat -> __ : Lt (nd 1) p -> Leq (log p (pow n m)) (times m (plus (log p n) (nd 1))) .
log_exp2 : p : Nat -> n : Nat -> m : Nat -> __ : Lt (nd 1) p -> __1 : Lt 0 n -> Leq (times m (log p n)) (log p (pow n m)) .
le_log_S : p : Nat -> n : Nat -> __ : Lt (nd 1) p -> Leq (log p n) (log p (plus n (nd 1))) .
le_log : p : Nat -> n : Nat -> m : Nat -> __ : Lt (nd 1) p -> __1 : Leq n m -> Leq (log p n) (log p m) .
log_div : p : Nat -> n : Nat -> m : Nat -> __ : Lt (nd 1) p -> __1 : Lt 0 m -> __2 : Leq m n -> Leq (log p (div n m)) (minus (log p n) (log p m)) .
log_n_n : n : Nat -> __ : Lt (nd 1) n -> Eq (log n n) (nd 1) .
log_i_2n : n : Nat -> i : Nat -> __ : Lt (nd 1) n -> __1 : Lt n i -> __2 : Leq i (times (nd 2) n) -> Eq (log i (times (nd 2) n)) (nd 1) .
exp_n_O : n : Nat -> __ : Lt 0 n -> Eq (pow 0 n) 0 .
ltransitive : B : Set -> predicate (prod Set Set Nat (__ : Nat => relation B)) .
inv_ltransitive : B : Set -> predicate (prod Set Set Nat (__ : Nat => relation B)) .
lstar : B : Set -> _R : relation B -> __ : Nat -> relation B .
lstar_O : B : Set -> R : relation B -> b : B -> lstar B R 0 b b .
lstar_S : B : Set -> R : relation B -> b1 : B -> b : B -> __ : R b1 b -> l : Nat -> b2 : B -> __1 : lstar B R l b b2 -> lstar B R (plus l (nd 1)) b1 b2 .
match_lstar : B : Set -> _R : relation B -> return_sort : Sort -> return_type : (__ : Nat -> __1 : B -> __2 : B -> z : lstar B _R __ __1 __2 -> return_sort) -> case_lstar_O : (b : B -> return_type 0 b b (lstar_O B _R b)) -> case_lstar_S : (b1 : B -> b : B -> __ : _R b1 b -> l : Nat -> b2 : B -> __1 : lstar B _R l b b2 -> return_type (plus l (nd 1)) b1 b2 (lstar_S B _R b1 b __ l b2 __1)) -> __ : Nat -> __1 : B -> __2 : B -> z : lstar B _R __ __1 __2 -> return_type __ __1 __2 z .
filter_lstar : B : Set -> _R : relation B -> __ : Nat -> __1 : B -> __2 : B -> return_sort : Sort -> return_type : (z : lstar B _R __ __1 __2 -> return_sort) -> return : (z : lstar B _R __ __1 __2 -> return_type z) -> z : lstar B _R __ __1 __2 -> return_type z .
lstar_ind : B : Set -> _R : relation B -> Q_ : (x_1233 : Nat -> x_1232 : B -> x_1231 : B -> _x_1234 : lstar B _R x_1233 x_1232 x_1231 -> Prop) -> _H_lstar_O : (b : B -> Q_ 0 b b (lstar_O B _R b)) -> _H_lstar_S : (b1 : B -> b : B -> x_1236 : _R b1 b -> l : Nat -> b2 : B -> x_1235 : lstar B _R l b b2 -> _x_1238 : Q_ l b b2 x_1235 -> Q_ (plus l (nd 1)) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> x_1233 : Nat -> x_1232 : B -> x_1231 : B -> x_1234 : lstar B _R x_1233 x_1232 x_1231 -> Q_ x_1233 x_1232 x_1231 x_1234 .
lstar_ind_body : B : Set -> _R : relation B -> Q_ : (x_1233 : Nat -> x_1232 : B -> x_1231 : B -> _x_1234 : lstar B _R x_1233 x_1232 x_1231 -> Prop) -> _H_lstar_O : (b : B -> Q_ 0 b b (lstar_O B _R b)) -> _H_lstar_S : (b1 : B -> b : B -> x_1236 : _R b1 b -> l : Nat -> b2 : B -> x_1235 : lstar B _R l b b2 -> _x_1238 : Q_ l b b2 x_1235 -> Q_ (plus l (nd 1)) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> x_1233 : Nat -> x_1232 : B -> x_1231 : B -> x_1234 : lstar B _R x_1233 x_1232 x_1231 -> Q_ x_1233 x_1232 x_1231 x_1234 .
lstar_inv_ind : x1 : Set -> x2 : relation x1 -> x3 : Nat -> x4 : x1 -> x5 : x1 -> _Hterm : lstar x1 x2 x3 x4 x5 -> P : (_z2089 : Nat -> _z2088 : x1 -> _z2087 : x1 -> Prop) -> _H1 : (b : x1 -> _z2092 : Eq x3 0 -> _z2091 : Eq x4 b -> _z2090 : Eq x5 b -> P 0 b b) -> _H2 : (b1 : x1 -> b : x1 -> _x_1236 : x2 b1 b -> l : Nat -> b2 : x1 -> _x_1235 : lstar x1 x2 l b b2 -> _x_1238 : (_z2092 : Eq x3 l -> _z2091 : Eq x4 b -> _z2090 : Eq x5 b2 -> P l b b2) -> _z2092 : Eq x3 (plus l (nd 1)) -> _z2091 : Eq x4 b1 -> _z2090 : Eq x5 b2 -> P (plus l (nd 1)) b1 b2) -> P x3 x4 x5 .
lstar_ind_l_aux : B : Set -> R : (__ : B -> __1 : B -> Prop) -> b2 : B -> P : relation2 Nat B -> __ : P 0 b2 -> __1 : (l : Nat -> b1 : B -> b : B -> __1 : R b1 b -> __2 : lstar B R l b b2 -> __3 : P l b -> P (plus l (nd 1)) b1) -> l : Nat -> b1 : B -> b : B -> __2 : lstar B R l b1 b -> __3 : Eq b b2 -> P l b1 .
lstar_ind_l : B : Set -> R : (__ : B -> __1 : B -> Prop) -> b2 : B -> P : relation2 Nat B -> __ : P 0 b2 -> __1 : (l : Nat -> b1 : B -> b : B -> __1 : R b1 b -> __2 : lstar B R l b b2 -> __3 : P l b -> P (plus l (nd 1)) b1) -> l : Nat -> b1 : B -> __2 : lstar B R l b1 b2 -> P l b1 .
lstar_step : B : Set -> R : (__ : B -> __1 : B -> Prop) -> b1 : B -> b2 : B -> __ : R b1 b2 -> lstar B R (nd 1) b1 b2 .
lstar_dx : B : Set -> R : relation B -> l : Nat -> b1 : B -> b : B -> __ : lstar B R l b1 b -> b2 : B -> __1 : R b b2 -> lstar B R (plus l (nd 1)) b1 b2 .
lstar_inv_O : B : Set -> R : relation B -> l : Nat -> b1 : B -> b2 : B -> __ : lstar B R l b1 b2 -> __1 : Eq 0 l -> Eq b1 b2 .
lstar_inv_S : B : Set -> R : relation B -> l : Nat -> b1 : B -> b2 : B -> __ : lstar B R l b1 b2 -> l0 : Nat -> __1 : Eq (plus l0 (nd 1)) l -> ex2 B (b : B => R b1 b) (b : B => lstar B R l0 b b2) .
lstar_inv_step : B : Set -> R : relation B -> b1 : B -> b2 : B -> __ : lstar B R (nd 1) b1 b2 -> R b1 b2 .
lstar_singlevalued : B : Set -> R : relation2 B B -> __ : singlevalued B B R -> l : Nat -> singlevalued B B (lstar B R l) .
lstar_ltransitive : B : Set -> R : relation B -> ltransitive B (lstar B R) .
lstar_inv_ltransitive : B : Set -> R : relation B -> inv_ltransitive B (lstar B R) .
lstar_inv_S_dx : B : Set -> R : relation B -> l : Nat -> b1 : B -> b2 : B -> __ : lstar B R (plus l (nd 1)) b1 b2 -> ex2 B (b : B => lstar B R l b1 b) (b : B => R b b2) .
lstar_r : B : Set -> _R : relation B -> __ : Nat -> relation B .
lstar_r_O : B : Set -> R : relation B -> b : B -> lstar_r B R 0 b b .
lstar_r_S : B : Set -> R : relation B -> l : Nat -> b1 : B -> b : B -> __ : lstar_r B R l b1 b -> b2 : B -> __1 : R b b2 -> lstar_r B R (plus l (nd 1)) b1 b2 .
match_lstar_r : B : Set -> _R : relation B -> return_sort : Sort -> return_type : (__ : Nat -> __1 : B -> __2 : B -> z : lstar_r B _R __ __1 __2 -> return_sort) -> case_lstar_r_O : (b : B -> return_type 0 b b (lstar_r_O B _R b)) -> case_lstar_r_S : (l : Nat -> b1 : B -> b : B -> __ : lstar_r B _R l b1 b -> b2 : B -> __1 : _R b b2 -> return_type (plus l (nd 1)) b1 b2 (lstar_r_S B _R l b1 b __ b2 __1)) -> __ : Nat -> __1 : B -> __2 : B -> z : lstar_r B _R __ __1 __2 -> return_type __ __1 __2 z .
filter_lstar_r : B : Set -> _R : relation B -> __ : Nat -> __1 : B -> __2 : B -> return_sort : Sort -> return_type : (z : lstar_r B _R __ __1 __2 -> return_sort) -> return : (z : lstar_r B _R __ __1 __2 -> return_type z) -> z : lstar_r B _R __ __1 __2 -> return_type z .
lstar_r_ind : B : Set -> _R : relation B -> Q_ : (x_1337 : Nat -> x_1336 : B -> x_1335 : B -> _x_1338 : lstar_r B _R x_1337 x_1336 x_1335 -> Prop) -> _H_lstar_r_O : (b : B -> Q_ 0 b b (lstar_r_O B _R b)) -> _H_lstar_r_S : (l : Nat -> b1 : B -> b : B -> x_1340 : lstar_r B _R l b1 b -> b2 : B -> x_1339 : _R b b2 -> _x_1342 : Q_ l b1 b x_1340 -> Q_ (plus l (nd 1)) b1 b2 (lstar_r_S B _R l b1 b x_1340 b2 x_1339)) -> x_1337 : Nat -> x_1336 : B -> x_1335 : B -> x_1338 : lstar_r B _R x_1337 x_1336 x_1335 -> Q_ x_1337 x_1336 x_1335 x_1338 .
lstar_r_ind_body : B : Set -> _R : relation B -> Q_ : (x_1337 : Nat -> x_1336 : B -> x_1335 : B -> _x_1338 : lstar_r B _R x_1337 x_1336 x_1335 -> Prop) -> _H_lstar_r_O : (b : B -> Q_ 0 b b (lstar_r_O B _R b)) -> _H_lstar_r_S : (l : Nat -> b1 : B -> b : B -> x_1340 : lstar_r B _R l b1 b -> b2 : B -> x_1339 : _R b b2 -> _x_1342 : Q_ l b1 b x_1340 -> Q_ (plus l (nd 1)) b1 b2 (lstar_r_S B _R l b1 b x_1340 b2 x_1339)) -> x_1337 : Nat -> x_1336 : B -> x_1335 : B -> x_1338 : lstar_r B _R x_1337 x_1336 x_1335 -> Q_ x_1337 x_1336 x_1335 x_1338 .
lstar_r_inv_ind : x1 : Set -> x2 : relation x1 -> x3 : Nat -> x4 : x1 -> x5 : x1 -> _Hterm : lstar_r x1 x2 x3 x4 x5 -> P : (_z2386 : Nat -> _z2385 : x1 -> _z2384 : x1 -> Prop) -> _H1 : (b : x1 -> _z2389 : Eq x3 0 -> _z2388 : Eq x4 b -> _z2387 : Eq x5 b -> P 0 b b) -> _H2 : (l : Nat -> b1 : x1 -> b : x1 -> _x_1340 : lstar_r x1 x2 l b1 b -> b2 : x1 -> _x_1339 : x2 b b2 -> _x_1342 : (_z2389 : Eq x3 l -> _z2388 : Eq x4 b1 -> _z2387 : Eq x5 b -> P l b1 b) -> _z2389 : Eq x3 (plus l (nd 1)) -> _z2388 : Eq x4 b1 -> _z2387 : Eq x5 b2 -> P (plus l (nd 1)) b1 b2) -> P x3 x4 x5 .
lstar_r_sn : B : Set -> R : relation B -> l : Nat -> b : B -> b2 : B -> __ : lstar_r B R l b b2 -> b1 : B -> __1 : R b1 b -> lstar_r B R (plus l (nd 1)) b1 b2 .
lstar_lstar_r : B : Set -> R : relation B -> l : Nat -> b1 : B -> b2 : B -> __ : lstar B R l b1 b2 -> lstar_r B R l b1 b2 .
lstar_r_inv_lstar : B : Set -> R : relation B -> l : Nat -> b1 : B -> b2 : B -> __ : lstar_r B R l b1 b2 -> lstar B R l b1 b2 .
lstar_ind_r_aux : B : Set -> R : relation B -> b1 : B -> P : relation2 Nat B -> __ : P 0 b1 -> __1 : (l : Nat -> b : B -> b2 : B -> __1 : lstar B R l b1 b -> __2 : R b b2 -> __3 : P l b -> P (plus l (nd 1)) b2) -> l : Nat -> b : B -> b2 : B -> __2 : lstar B R l b b2 -> __3 : Eq b b1 -> P l b2 .
lstar_ind_r : B : Set -> R : relation B -> b1 : B -> P : relation2 Nat B -> __ : P 0 b1 -> __1 : (l : Nat -> b : B -> b2 : B -> __1 : lstar B R l b1 b -> __2 : R b b2 -> __3 : P l b -> P (plus l (nd 1)) b2) -> l : Nat -> b2 : B -> __2 : lstar B R l b1 b2 -> P l b2 .
lstar_Conf3 : A : Set -> B : Set -> succ : relation2 A B -> R : relation A -> __ : Conf3 A B succ R -> l : Nat -> Conf3 A B succ (lstar A R l) .
max' : __ : Nat -> __1 : (__1 : Nat -> bool) -> __2 : Nat -> Nat .
max'_body : __ : Nat -> __1 : (__1 : Nat -> bool) -> __2 : Nat -> Nat .
max : _n : Nat -> _f : (__ : Nat -> bool) -> Nat .
max_O : f : (__ : Nat -> bool) -> Eq (max 0 f) 0 .
max_cases : f : (__ : Nat -> bool) -> n : Nat -> or (and (Eq (f n) true) (Eq (max (plus n (nd 1)) f) n)) (and (Eq (f n) false) (Eq (max (plus n (nd 1)) f) (max n f))) .
le_max_n : f : (__ : Nat -> bool) -> n : Nat -> Leq (max n f) n .
lt_max_n : f : (__ : Nat -> bool) -> n : Nat -> __ : Lt 0 n -> Lt (max n f) n .
le_to_le_max : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> __ : Leq n m -> Leq (max n f) (max m f) .
true_to_le_max : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> __ : Lt m n -> __1 : Eq (f m) true -> Leq m (max n f) .
lt_max_to_false : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> __ : Lt m n -> __1 : Lt (max n f) m -> Eq (f m) false .
max_exists : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> __ : Lt m n -> __1 : Eq (f m) true -> __2 : (i : Nat -> __2 : Lt m i -> __3 : Lt i n -> Eq (f i) false) -> Eq (max n f) m .
max_not_exists : f : (__ : Nat -> bool) -> n : Nat -> __ : (i : Nat -> __ : Lt i n -> Eq (f i) false) -> Eq (max n f) 0 .
let_clause_1013 : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> i : Nat -> Hind : (__ : Eq (max i f) m -> __1 : Eq (f m) false -> Eq m 0) -> fi : Eq (f i) true -> eqm : Eq i m -> fm : Eq (f m) false -> Eq false true .
fmax_false : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> __ : Eq (max n f) m -> __1 : Eq (f m) false -> Eq m 0 .
max_spec : _n : Nat -> _f : (__ : Nat -> bool) -> __ : Nat -> Prop .
found_max_spec : n : Nat -> f : (__ : Nat -> bool) -> m : Nat -> __ : Lt m n -> __1 : Eq (f m) true -> __2 : (i : Nat -> __2 : Lt m i -> __3 : Lt i n -> Eq (f i) false) -> max_spec n f m .
not_found_max_spec : n : Nat -> f : (__ : Nat -> bool) -> __ : (i : Nat -> __ : Lt i n -> Eq (f i) false) -> max_spec n f 0 .
match_max_spec : _n : Nat -> _f : (__ : Nat -> bool) -> return_sort : Sort -> return_type : (__ : Nat -> z : max_spec _n _f __ -> return_sort) -> case_found_max_spec : (m : Nat -> __ : Lt m _n -> __1 : Eq (_f m) true -> __2 : (i : Nat -> __2 : Lt m i -> __3 : Lt i _n -> Eq (_f i) false) -> return_type m (found_max_spec _n _f m __ __1 __2)) -> case_not_found_max_spec : (__ : (i : Nat -> __ : Lt i _n -> Eq (_f i) false) -> return_type 0 (not_found_max_spec _n _f __)) -> __ : Nat -> z : max_spec _n _f __ -> return_type __ z .
filter_max_spec : _n : Nat -> _f : (__ : Nat -> bool) -> __ : Nat -> return_sort : Sort -> return_type : (z : max_spec _n _f __ -> return_sort) -> return : (z : max_spec _n _f __ -> return_type z) -> z : max_spec _n _f __ -> return_type z .
max_spec_ind : _n : Nat -> _f : (__ : Nat -> bool) -> Q_ : (x_971 : Nat -> _x_972 : max_spec _n _f x_971 -> Prop) -> _H_found_max_spec : (m : Nat -> x_975 : Lt m _n -> x_974 : Eq (_f m) true -> x_973 : (i : Nat -> __ : Lt m i -> __1 : Lt i _n -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> _H_not_found_max_spec : (x_976 : (i : Nat -> __ : Lt i _n -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> x_971 : Nat -> x_972 : max_spec _n _f x_971 -> Q_ x_971 x_972 .
max_spec_ind_body : _n : Nat -> _f : (__ : Nat -> bool) -> Q_ : (x_971 : Nat -> _x_972 : max_spec _n _f x_971 -> Prop) -> _H_found_max_spec : (m : Nat -> x_975 : Lt m _n -> x_974 : Eq (_f m) true -> x_973 : (i : Nat -> __ : Lt m i -> __1 : Lt i _n -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> _H_not_found_max_spec : (x_976 : (i : Nat -> __ : Lt i _n -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> x_971 : Nat -> x_972 : max_spec _n _f x_971 -> Q_ x_971 x_972 .
max_spec_inv_ind : x1 : Nat -> x2 : (__ : Nat -> bool) -> x3 : Nat -> _Hterm : max_spec x1 x2 x3 -> P : (_z1769 : Nat -> Prop) -> _H1 : (m : Nat -> _x_975 : Lt m x1 -> _x_974 : Eq (x2 m) true -> _x_973 : (i : Nat -> __ : Lt m i -> __1 : Lt i x1 -> Eq (x2 i) false) -> _z1770 : Eq x3 m -> P m) -> _H2 : (_x_976 : (i : Nat -> __ : Lt i x1 -> Eq (x2 i) false) -> _z1770 : Eq x3 0 -> P 0) -> P x3 .
max_spec_to_max : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> __ : max_spec n f m -> Eq (max n f) m .
let_clause_10131 : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> n0 : Nat -> eqm : Eq (max (plus n0 (nd 1)) f) m -> fm : Eq (f m) false -> i : Nat -> j : Nat -> ltj : Lt (plus j (nd 1)) (plus n0 (nd 1)) -> x7 : Nat -> Eq x7 (plus m x7) .
max_to_max_spec : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> __ : Eq (max n f) m -> max_spec n f m .
max_f_g : f : (__ : Nat -> bool) -> g : (__ : Nat -> bool) -> n : Nat -> __ : (i : Nat -> __ : Lt i n -> Eq (f i) (g i)) -> Eq (max n f) (max n g) .
le_max_f_max_g : f : (__ : Nat -> bool) -> g : (__ : Nat -> bool) -> n : Nat -> __ : (i : Nat -> __ : Lt i n -> __1 : Eq (f i) true -> Eq (g i) true) -> Leq (max n f) (max n g) .
f_max_true : f : (__ : Nat -> bool) -> n : Nat -> __ : ex Nat (i : Nat => and (Lt i n) (Eq (f i) true)) -> Eq (f (max n f)) true .
f_false_to_le_max : f : (__ : Nat -> bool) -> n : Nat -> p : Nat -> __ : ex Nat (i : Nat => and (Lt i n) (Eq (f i) true)) -> __1 : (m : Nat -> __1 : Lt p m -> Eq (f m) false) -> Leq (max n f) p .
exists_forall_lt : f : (__ : Nat -> bool) -> n : Nat -> or (ex Nat (i : Nat => and (Lt i n) (Eq (f i) true))) (prod Set Prop Nat (i : Nat => prod Prop Prop (Lt i n) (__ : Lt i n => Eq (f i) false))) .
exists_max_forall_false : f : (__ : Nat -> bool) -> n : Nat -> or (and (ex Nat (i : Nat => and (Lt i n) (Eq (f i) true))) (Eq (f (max n f)) true)) (and (prod Set Prop Nat (i : Nat => prod Prop Prop (Lt i n) (__ : Lt i n => Eq (f i) false))) (Eq (max n f) 0)) .
let_clause_1009 : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> posn : Lt 0 n -> Hfn : Eq (f n) false -> Hmax : Leq (max m f) n -> Hmax0 : Eq (max m f) n -> _clearme : and (prod Set Prop Nat (i : Nat => prod Prop Prop (Lt i m) (__ : Lt i m => Eq (f i) false))) (Eq (max m f) 0) -> auto : (i : Nat -> __ : Lt i m -> Eq (f i) false) -> auto' : Eq (max m f) 0 -> Eq 0 n .
false_to_lt_max : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : Eq (f n) false -> __2 : Leq (max m f) n -> Lt (max m f) n .
min : __ : Nat -> __1 : Nat -> __2 : (__2 : Nat -> bool) -> Nat .
min_body : __ : Nat -> __1 : Nat -> __2 : (__2 : Nat -> bool) -> Nat .
min0 : _n : Nat -> _f : (__ : Nat -> bool) -> Nat .
min_O_f : f : (__ : Nat -> bool) -> b : Nat -> Eq (min 0 b f) b .
true_min : f : (__ : Nat -> bool) -> b : Nat -> __ : Eq (f b) true -> n : Nat -> Eq (min n b f) b .
false_min : f : (__ : Nat -> bool) -> n : Nat -> b : Nat -> __ : Eq (f b) false -> Eq (min (plus n (nd 1)) b f) (min n (plus b (nd 1)) f) .
le_min_r : f : (__ : Nat -> bool) -> n : Nat -> b : Nat -> Leq (min n b f) (plus n b) .
le_min_l : f : (__ : Nat -> bool) -> n : Nat -> b : Nat -> Leq b (min n b f) .
le_to_le_min : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> __ : Leq n m -> b : Nat -> Leq (min n b f) (min m b f) .
true_to_le_min : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> b : Nat -> __ : Leq b m -> __1 : Eq (f m) true -> Leq (min n b f) m .
lt_min_to_false : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> b : Nat -> __ : Leq b m -> __1 : Lt m (min n b f) -> Eq (f m) false .
fmin_true : f : (__ : Nat -> bool) -> n : Nat -> m : Nat -> b : Nat -> __ : Eq m (min n b f) -> __1 : Lt m (plus n b) -> Eq (f m) true .
min_exists : f : (__ : Nat -> bool) -> t : Nat -> m : Nat -> __ : Lt m t -> __1 : Eq (f m) true -> k : Nat -> b : Nat -> __2 : Leq b m -> __3 : (i : Nat -> __3 : Leq b i -> __4 : Lt i m -> Eq (f i) false) -> __4 : Eq t (plus k b) -> Eq (min k b f) m .
min_not_exists : f : (__ : Nat -> bool) -> n : Nat -> b : Nat -> __ : (i : Nat -> __ : Leq b i -> __1 : Lt i (plus n b) -> Eq (f i) false) -> Eq (min n b f) (plus n b) .
let_m : f : (__ : Nat -> bool) -> n : Nat -> b : Nat -> Nat .
let_m1 : f : (__ : Nat -> bool) -> n : Nat -> _x_365 : Nat -> b : Nat -> Nat .
let_m2 : f : (__ : Nat -> bool) -> n : Nat -> i : Nat -> b : Nat -> Nat .
let_clause_1012 : f : (__ : Nat -> bool) -> n : Nat -> i : Nat -> Hind : (b : Nat -> prod Prop Prop (Eq (f (let_m2 f n i b)) false) (__ : Eq (f (let_m2 f n i b)) false => Eq (let_m2 f n i b) (plus i b))) -> b : Nat -> fb : Eq (f b) true -> eqm : Eq (f b) false -> Eq false true .
fmin_false : f : (__ : Nat -> bool) -> n : Nat -> b : Nat -> prod Prop Prop (Eq (f (let_m f n b)) false) (__ : Eq (f (let_m f n b)) false => Eq (let_m f n b) (plus n b)) .
min_spec : _n : Nat -> _b : Nat -> _f : (__ : Nat -> bool) -> __ : Nat -> Prop .
found_min_spec : n : Nat -> b : Nat -> f : (__ : Nat -> bool) -> m : Nat -> __ : Leq b m -> __1 : Lt m (plus n b) -> __2 : Eq (f m) true -> __3 : (i : Nat -> __3 : Leq b i -> __4 : Lt i m -> Eq (f i) false) -> min_spec n b f m .
not_found_min_spec : n : Nat -> b : Nat -> f : (__ : Nat -> bool) -> __ : (i : Nat -> __ : Leq b i -> __1 : Lt i (plus n b) -> Eq (f i) false) -> min_spec n b f (plus n b) .
match_min_spec : _n : Nat -> _b : Nat -> _f : (__ : Nat -> bool) -> return_sort : Sort -> return_type : (__ : Nat -> z : min_spec _n _b _f __ -> return_sort) -> case_found_min_spec : (m : Nat -> __ : Leq _b m -> __1 : Lt m (plus _n _b) -> __2 : Eq (_f m) true -> __3 : (i : Nat -> __3 : Leq _b i -> __4 : Lt i m -> Eq (_f i) false) -> return_type m (found_min_spec _n _b _f m __ __1 __2 __3)) -> case_not_found_min_spec : (__ : (i : Nat -> __ : Leq _b i -> __1 : Lt i (plus _n _b) -> Eq (_f i) false) -> return_type (plus _n _b) (not_found_min_spec _n _b _f __)) -> __ : Nat -> z : min_spec _n _b _f __ -> return_type __ z .
filter_min_spec : _n : Nat -> _b : Nat -> _f : (__ : Nat -> bool) -> __ : Nat -> return_sort : Sort -> return_type : (z : min_spec _n _b _f __ -> return_sort) -> return : (z : min_spec _n _b _f __ -> return_type z) -> z : min_spec _n _b _f __ -> return_type z .
min_spec_ind : _n : Nat -> _b : Nat -> _f : (__ : Nat -> bool) -> Q_ : (x_1075 : Nat -> _x_1076 : min_spec _n _b _f x_1075 -> Prop) -> _H_found_min_spec : (m : Nat -> x_1080 : Leq _b m -> x_1079 : Lt m (plus _n _b) -> x_1078 : Eq (_f m) true -> x_1077 : (i : Nat -> __ : Leq _b i -> __1 : Lt i m -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> _H_not_found_min_spec : (x_1081 : (i : Nat -> __ : Leq _b i -> __1 : Lt i (plus _n _b) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> x_1075 : Nat -> x_1076 : min_spec _n _b _f x_1075 -> Q_ x_1075 x_1076 .
min_spec_ind_body : _n : Nat -> _b : Nat -> _f : (__ : Nat -> bool) -> Q_ : (x_1075 : Nat -> _x_1076 : min_spec _n _b _f x_1075 -> Prop) -> _H_found_min_spec : (m : Nat -> x_1080 : Leq _b m -> x_1079 : Lt m (plus _n _b) -> x_1078 : Eq (_f m) true -> x_1077 : (i : Nat -> __ : Leq _b i -> __1 : Lt i m -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> _H_not_found_min_spec : (x_1081 : (i : Nat -> __ : Leq _b i -> __1 : Lt i (plus _n _b) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> x_1075 : Nat -> x_1076 : min_spec _n _b _f x_1075 -> Q_ x_1075 x_1076 .
min_spec_inv_ind : x1 : Nat -> x2 : Nat -> x3 : (__ : Nat -> bool) -> x4 : Nat -> _Hterm : min_spec x1 x2 x3 x4 -> P : (_z1890 : Nat -> Prop) -> _H1 : (m : Nat -> _x_1080 : Leq x2 m -> _x_1079 : Lt m (plus x1 x2) -> _x_1078 : Eq (x3 m) true -> _x_1077 : (i : Nat -> __ : Leq x2 i -> __1 : Lt i m -> Eq (x3 i) false) -> _z1891 : Eq x4 m -> P m) -> _H2 : (_x_1081 : (i : Nat -> __ : Leq x2 i -> __1 : Lt i (plus x1 x2) -> Eq (x3 i) false) -> _z1891 : Eq x4 (plus x1 x2) -> P (plus x1 x2)) -> P x4 .
min_spec_to_min : f : (__ : Nat -> bool) -> n : Nat -> b : Nat -> m : Nat -> __ : min_spec n b f m -> Eq (min n b f) m .
min_to_min_spec : f : (__ : Nat -> bool) -> n : Nat -> b : Nat -> m : Nat -> __ : Eq (min n b f) m -> min_spec n b f m .
min_f_g : f : (__ : Nat -> bool) -> g : (__ : Nat -> bool) -> n : Nat -> b : Nat -> __ : (i : Nat -> __ : Leq b i -> __1 : Lt i (plus n b) -> Eq (f i) (g i)) -> Eq (min n b f) (min n b g) .
le_min_f_min_g : f : (__ : Nat -> bool) -> g : (__ : Nat -> bool) -> n : Nat -> b : Nat -> __ : (i : Nat -> __ : Leq b i -> __1 : Lt i (plus n b) -> __2 : Eq (f i) true -> Eq (g i) true) -> Leq (min n b g) (min n b f) .
f_min_true : f : (__ : Nat -> bool) -> n : Nat -> b : Nat -> __ : ex Nat (i : Nat => and (and (Leq b i) (Lt i (plus n b))) (Eq (f i) true)) -> Eq (f (min n b f)) true .
lt_min : f : (__ : Nat -> bool) -> n : Nat -> b : Nat -> __ : ex Nat (i : Nat => and (and (Leq b i) (Lt i (plus n b))) (Eq (f i) true)) -> Lt (min n b f) (plus n b) .
Nat : Set .
0 : Nat .
succ : __ : Nat -> Nat .
match_nat : return_sort : Sort -> return_type : (z : Nat -> return_sort) -> case_O : return_type 0 -> case_S : (__ : Nat -> return_type (plus __ (nd 1))) -> z : Nat -> return_type z .
filter_nat : return_sort : Sort -> return_type : (z : Nat -> return_sort) -> return : (z : Nat -> return_type z) -> z : Nat -> return_type z .
nat_ind : Q_ : (_x_365 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_366 : Nat -> _x_368 : Q_ x_366 -> Q_ (plus x_366 (nd 1))) -> x_365 : Nat -> Q_ x_365 .
nat_ind_body : Q_ : (_x_365 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_366 : Nat -> _x_368 : Q_ x_366 -> Q_ (plus x_366 (nd 1))) -> x_365 : Nat -> Q_ x_365 .
nat_rect_Type4 : Q_ : (_x_369 : Nat -> Type4) -> _H_O : Q_ 0 -> _H_S : (x_370 : Nat -> _x_372 : Q_ x_370 -> Q_ (plus x_370 (nd 1))) -> x_369 : Nat -> Q_ x_369 .
nat_rect_Type4_body : Q_ : (_x_369 : Nat -> Type4) -> _H_O : Q_ 0 -> _H_S : (x_370 : Nat -> _x_372 : Q_ x_370 -> Q_ (plus x_370 (nd 1))) -> x_369 : Nat -> Q_ x_369 .
nat_rect_Type3 : Q_ : (_x_377 : Nat -> Type3) -> _H_O : Q_ 0 -> _H_S : (x_378 : Nat -> _x_380 : Q_ x_378 -> Q_ (plus x_378 (nd 1))) -> x_377 : Nat -> Q_ x_377 .
nat_rect_Type3_body : Q_ : (_x_377 : Nat -> Type3) -> _H_O : Q_ 0 -> _H_S : (x_378 : Nat -> _x_380 : Q_ x_378 -> Q_ (plus x_378 (nd 1))) -> x_377 : Nat -> Q_ x_377 .
nat_rect_Type2 : Q_ : (_x_381 : Nat -> Type2) -> _H_O : Q_ 0 -> _H_S : (x_382 : Nat -> _x_384 : Q_ x_382 -> Q_ (plus x_382 (nd 1))) -> x_381 : Nat -> Q_ x_381 .
nat_rect_Type2_body : Q_ : (_x_381 : Nat -> Type2) -> _H_O : Q_ 0 -> _H_S : (x_382 : Nat -> _x_384 : Q_ x_382 -> Q_ (plus x_382 (nd 1))) -> x_381 : Nat -> Q_ x_381 .
nat_rect_Type1 : Q_ : (_x_385 : Nat -> Type1) -> _H_O : Q_ 0 -> _H_S : (x_386 : Nat -> _x_388 : Q_ x_386 -> Q_ (plus x_386 (nd 1))) -> x_385 : Nat -> Q_ x_385 .
nat_rect_Type1_body : Q_ : (_x_385 : Nat -> Type1) -> _H_O : Q_ 0 -> _H_S : (x_386 : Nat -> _x_388 : Q_ x_386 -> Q_ (plus x_386 (nd 1))) -> x_385 : Nat -> Q_ x_385 .
nat_rect_Type0 : Q_ : (_x_389 : Nat -> Set) -> _H_O : Q_ 0 -> _H_S : (x_390 : Nat -> _x_392 : Q_ x_390 -> Q_ (plus x_390 (nd 1))) -> x_389 : Nat -> Q_ x_389 .
nat_rect_Type0_body : Q_ : (_x_389 : Nat -> Set) -> _H_O : Q_ 0 -> _H_S : (x_390 : Nat -> _x_392 : Q_ x_390 -> Q_ (plus x_390 (nd 1))) -> x_389 : Nat -> Q_ x_389 .
nat_rect_CProp4 : Q_ : (_x_393 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_394 : Nat -> _x_396 : Q_ x_394 -> Q_ (plus x_394 (nd 1))) -> x_393 : Nat -> Q_ x_393 .
nat_rect_CProp4_body : Q_ : (_x_393 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_394 : Nat -> _x_396 : Q_ x_394 -> Q_ (plus x_394 (nd 1))) -> x_393 : Nat -> Q_ x_393 .
nat_rect_CProp3 : Q_ : (_x_401 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_402 : Nat -> _x_404 : Q_ x_402 -> Q_ (plus x_402 (nd 1))) -> x_401 : Nat -> Q_ x_401 .
nat_rect_CProp3_body : Q_ : (_x_401 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_402 : Nat -> _x_404 : Q_ x_402 -> Q_ (plus x_402 (nd 1))) -> x_401 : Nat -> Q_ x_401 .
nat_rect_CProp2 : Q_ : (_x_405 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_406 : Nat -> _x_408 : Q_ x_406 -> Q_ (plus x_406 (nd 1))) -> x_405 : Nat -> Q_ x_405 .
nat_rect_CProp2_body : Q_ : (_x_405 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_406 : Nat -> _x_408 : Q_ x_406 -> Q_ (plus x_406 (nd 1))) -> x_405 : Nat -> Q_ x_405 .
nat_rect_CProp1 : Q_ : (_x_409 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_410 : Nat -> _x_412 : Q_ x_410 -> Q_ (plus x_410 (nd 1))) -> x_409 : Nat -> Q_ x_409 .
nat_rect_CProp1_body : Q_ : (_x_409 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_410 : Nat -> _x_412 : Q_ x_410 -> Q_ (plus x_410 (nd 1))) -> x_409 : Nat -> Q_ x_409 .
nat_rect_CProp0 : Q_ : (_x_413 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_414 : Nat -> _x_416 : Q_ x_414 -> Q_ (plus x_414 (nd 1))) -> x_413 : Nat -> Q_ x_413 .
nat_rect_CProp0_body : Q_ : (_x_413 : Nat -> Prop) -> _H_O : Q_ 0 -> _H_S : (x_414 : Nat -> _x_416 : Q_ x_414 -> Q_ (plus x_414 (nd 1))) -> x_413 : Nat -> Q_ x_413 .
nat_inv_ind : Hterm : Nat -> P : (_z653 : Nat -> Prop) -> _H1 : (_z654 : Eq Hterm 0 -> P 0) -> _H2 : (x_366 : Nat -> _x_368 : (_z654 : Eq Hterm x_366 -> P x_366) -> _z654 : Eq Hterm (plus x_366 (nd 1)) -> P (plus x_366 (nd 1))) -> P Hterm .
nat_inv_rect_Type4 : Hterm : Nat -> P : (_z659 : Nat -> Type4) -> _H1 : (_z660 : Eq Hterm 0 -> P 0) -> _H2 : (x_370 : Nat -> _x_372 : (_z660 : Eq Hterm x_370 -> P x_370) -> _z660 : Eq Hterm (plus x_370 (nd 1)) -> P (plus x_370 (nd 1))) -> P Hterm .
nat_inv_rect_Type3 : Hterm : Nat -> P : (_z665 : Nat -> Type3) -> _H1 : (_z666 : Eq Hterm 0 -> P 0) -> _H2 : (x_378 : Nat -> _x_380 : (_z666 : Eq Hterm x_378 -> P x_378) -> _z666 : Eq Hterm (plus x_378 (nd 1)) -> P (plus x_378 (nd 1))) -> P Hterm .
nat_inv_rect_Type2 : Hterm : Nat -> P : (_z671 : Nat -> Type2) -> _H1 : (_z672 : Eq Hterm 0 -> P 0) -> _H2 : (x_382 : Nat -> _x_384 : (_z672 : Eq Hterm x_382 -> P x_382) -> _z672 : Eq Hterm (plus x_382 (nd 1)) -> P (plus x_382 (nd 1))) -> P Hterm .
nat_inv_rect_Type1 : Hterm : Nat -> P : (_z677 : Nat -> Type1) -> _H1 : (_z678 : Eq Hterm 0 -> P 0) -> _H2 : (x_386 : Nat -> _x_388 : (_z678 : Eq Hterm x_386 -> P x_386) -> _z678 : Eq Hterm (plus x_386 (nd 1)) -> P (plus x_386 (nd 1))) -> P Hterm .
nat_inv_rect_Type0 : Hterm : Nat -> P : (_z683 : Nat -> Set) -> _H1 : (_z684 : Eq Hterm 0 -> P 0) -> _H2 : (x_390 : Nat -> _x_392 : (_z684 : Eq Hterm x_390 -> P x_390) -> _z684 : Eq Hterm (plus x_390 (nd 1)) -> P (plus x_390 (nd 1))) -> P Hterm .
nat_inv_rect_CProp4 : Hterm : Nat -> P : (_z689 : Nat -> Prop) -> _H1 : (_z690 : Eq Hterm 0 -> P 0) -> _H2 : (x_394 : Nat -> _x_396 : (_z690 : Eq Hterm x_394 -> P x_394) -> _z690 : Eq Hterm (plus x_394 (nd 1)) -> P (plus x_394 (nd 1))) -> P Hterm .
nat_inv_rect_CProp3 : Hterm : Nat -> P : (_z695 : Nat -> Prop) -> _H1 : (_z696 : Eq Hterm 0 -> P 0) -> _H2 : (x_402 : Nat -> _x_404 : (_z696 : Eq Hterm x_402 -> P x_402) -> _z696 : Eq Hterm (plus x_402 (nd 1)) -> P (plus x_402 (nd 1))) -> P Hterm .
nat_inv_rect_CProp2 : Hterm : Nat -> P : (_z701 : Nat -> Prop) -> _H1 : (_z702 : Eq Hterm 0 -> P 0) -> _H2 : (x_406 : Nat -> _x_408 : (_z702 : Eq Hterm x_406 -> P x_406) -> _z702 : Eq Hterm (plus x_406 (nd 1)) -> P (plus x_406 (nd 1))) -> P Hterm .
nat_inv_rect_CProp1 : Hterm : Nat -> P : (_z707 : Nat -> Prop) -> _H1 : (_z708 : Eq Hterm 0 -> P 0) -> _H2 : (x_410 : Nat -> _x_412 : (_z708 : Eq Hterm x_410 -> P x_410) -> _z708 : Eq Hterm (plus x_410 (nd 1)) -> P (plus x_410 (nd 1))) -> P Hterm .
nat_inv_rect_CProp0 : Hterm : Nat -> P : (_z713 : Nat -> Prop) -> _H1 : (_z714 : Eq Hterm 0 -> P 0) -> _H2 : (x_414 : Nat -> _x_416 : (_z714 : Eq Hterm x_414 -> P x_414) -> _z714 : Eq Hterm (plus x_414 (nd 1)) -> P (plus x_414 (nd 1))) -> P Hterm .
nat_discr : x : Nat -> y : Nat -> _e : Eq x y -> match_nat (plus Type2 (nd 1)) (__ : Nat => univ Type2) (match_nat (plus Type2 (nd 1)) (__ : Nat => univ Type2) (prod (plus Type1 (nd 1)) Type1 (univ Type1) (P : Type1 => prod Type1 Type1 P (_z23 : P => P))) (u0 : Nat => prod (plus Type1 (nd 1)) Type1 (univ Type1) (P : Type1 => P)) y) (t0 : Nat => match_nat (plus Type2 (nd 1)) (__ : Nat => univ Type2) (prod (plus Type1 (nd 1)) Type1 (univ Type1) (P : Type1 => P)) (u0 : Nat => prod (plus Type1 (nd 1)) Type1 (univ Type1) (P : Type1 => prod Type1 Type1 (prod Prop Type1 (Eq (R0 Nat t0) u0) (_e0 : Eq (R0 Nat t0) u0 => P)) (_z24 : (_e0 : Eq (R0 Nat t0) u0 -> P) => P))) y) x .
pred : _n : Nat -> Nat .
not_zero : __ : Nat -> Prop .
Leq : _n : Nat -> __ : Nat -> Prop .
le_n : n : Nat -> Leq n n .
le_S : n : Nat -> m : Nat -> __ : Leq n m -> Leq n (plus m (nd 1)) .
match_le : _n : Nat -> return_sort : Sort -> return_type : (__ : Nat -> z : Leq _n __ -> return_sort) -> case_le_n : return_type _n (le_n _n) -> case_le_S : (m : Nat -> __ : Leq _n m -> return_type (plus m (nd 1)) (le_S _n m __)) -> __ : Nat -> z : Leq _n __ -> return_type __ z .
filter_le : _n : Nat -> __ : Nat -> return_sort : Sort -> return_type : (z : Leq _n __ -> return_sort) -> return : (z : Leq _n __ -> return_type z) -> z : Leq _n __ -> return_type z .
le_ind : _n : Nat -> Q_ : (x_417 : Nat -> _x_418 : Leq _n x_417 -> Prop) -> _H_le_n : Q_ _n (le_n _n) -> _H_le_S : (m : Nat -> x_419 : Leq _n m -> _x_421 : Q_ m x_419 -> Q_ (plus m (nd 1)) (le_S _n m x_419)) -> x_417 : Nat -> x_418 : Leq _n x_417 -> Q_ x_417 x_418 .
le_ind_body : _n : Nat -> Q_ : (x_417 : Nat -> _x_418 : Leq _n x_417 -> Prop) -> _H_le_n : Q_ _n (le_n _n) -> _H_le_S : (m : Nat -> x_419 : Leq _n m -> _x_421 : Q_ m x_419 -> Q_ (plus m (nd 1)) (le_S _n m x_419)) -> x_417 : Nat -> x_418 : Leq _n x_417 -> Q_ x_417 x_418 .
le_inv_ind : x1 : Nat -> x2 : Nat -> _Hterm : Leq x1 x2 -> P : (_z724 : Nat -> Prop) -> _H1 : (_z725 : Eq x2 x1 -> P x1) -> _H2 : (m : Nat -> _x_419 : Leq x1 m -> _x_421 : (_z725 : Eq x2 m -> P m) -> _z725 : Eq x2 (plus m (nd 1)) -> P (plus m (nd 1))) -> P x2 .
Lt : __ : Nat -> __1 : Nat -> Prop .
Geq : __ : Nat -> __1 : Nat -> Prop .
Gt : __ : Nat -> __1 : Nat -> Prop .
increasing : _f : (__ : Nat -> Nat) -> Prop .
plus : __ : Nat -> __1 : Nat -> Nat .
plus_body : __ : Nat -> __1 : Nat -> Nat .
times : __ : Nat -> __1 : Nat -> Nat .
times_body : __ : Nat -> __1 : Nat -> Nat .
minus : __ : Nat -> __1 : Nat -> Nat .
minus_body : __ : Nat -> __1 : Nat -> Nat .
nat_case : n : Nat -> P : (__ : Nat -> Prop) -> __ : (__ : Eq n 0 -> P 0) -> __1 : (m : Nat -> __1 : Eq n (plus m (nd 1)) -> P (plus m (nd 1))) -> P n .
nat_elim2 : R : (__ : Nat -> __1 : Nat -> Prop) -> __ : (n : Nat -> R 0 n) -> __1 : (n : Nat -> R (plus n (nd 1)) 0) -> __2 : (n : Nat -> m : Nat -> __2 : R n m -> R (plus n (nd 1)) (plus m (nd 1))) -> n : Nat -> m : Nat -> R n m .
le_gen : P : (__ : Nat -> Prop) -> n : Nat -> __ : (i : Nat -> __ : Leq i n -> P i) -> P n .
pred_Sn : n : Nat -> Eq n (pred (plus n (nd 1))) .
injective_S : injectif Nat Nat succ .
S_pred : n : Nat -> __ : Lt 0 n -> Eq (plus (pred n) (nd 1)) n .
plus_O_n : n : Nat -> Eq n (plus 0 n) .
plus_n_O : n : Nat -> Eq n (plus n 0) .
plus_n_Sm : n : Nat -> m : Nat -> Eq (plus (plus n m) (nd 1)) (plus n (plus m (nd 1))) .
commutative_plus : commutative Nat plus .
associative_plus : associative Nat plus .
assoc_plus1 : a : Nat -> b : Nat -> c : Nat -> Eq (plus c (plus b a)) (plus (plus b c) a) .
injective_plus_r : n : Nat -> injectif Nat Nat (m : Nat => plus n m) .
injective_plus_l : n : Nat -> injectif Nat Nat (m : Nat => plus m n) .
times_Sn_m : n : Nat -> m : Nat -> Eq (plus m (times n m)) (times (plus n (nd 1)) m) .
times_O_n : n : Nat -> Eq 0 (times 0 n) .
times_n_O : n : Nat -> Eq 0 (times n 0) .
times_n_Sm : n : Nat -> m : Nat -> Eq (plus n (times n m)) (times n (plus m (nd 1))) .
commutative_times : commutative Nat times .
distributive_times_plus : distributive Nat times plus .
distributive_times_plus_r : a : Nat -> b : Nat -> c : Nat -> Eq (times (plus b c) a) (plus (times b a) (times c a)) .
associative_times : associative Nat times .
times_times : x : Nat -> y : Nat -> z : Nat -> Eq (times x (times y z)) (times y (times x z)) .
times_n_1 : n : Nat -> Eq n (times n (nd 1)) .
minus_S_S : n : Nat -> m : Nat -> Eq (minus (plus n (nd 1)) (plus m (nd 1))) (minus n m) .
minus_O_n : n : Nat -> Eq 0 (minus 0 n) .
minus_n_O : n : Nat -> Eq n (minus n 0) .
minus_n_n : n : Nat -> Eq 0 (minus n n) .
minus_Sn_n : n : Nat -> Eq (nd 1) (minus (plus n (nd 1)) n) .
eq_minus_S_pred : n : Nat -> m : Nat -> Eq (minus n (plus m (nd 1))) (pred (minus n m)) .
let_clause_73 : x : Nat -> y : Nat -> z : Nat -> x134 : Nat -> x135 : Nat -> x136 : Nat -> Eq (plus x134 (plus x135 x136)) (plus x135 (plus x134 x136)) .
plus_plus_comm_23 : x : Nat -> y : Nat -> z : Nat -> Eq (plus (plus x y) z) (plus (plus x z) y) .
discr_plus_xy_minus_xz : x : Nat -> z : Nat -> y : Nat -> __ : Eq (plus x y) (minus x z) -> Eq y 0 .
not_eq_S : n : Nat -> m : Nat -> __ : not (Eq n m) -> not (Eq (plus n (nd 1)) (plus m (nd 1))) .
not_eq_O_S : n : Nat -> not (Eq 0 (plus n (nd 1))) .
not_eq_n_Sn : n : Nat -> not (Eq n (plus n (nd 1))) .
lt_to_not_zero : n : Nat -> m : Nat -> __ : Lt n m -> not_zero m .
le_S_S : n : Nat -> m : Nat -> __ : Leq n m -> Leq (plus n (nd 1)) (plus m (nd 1)) .
le_O_n : n : Nat -> Leq 0 n .
le_n_Sn : n : Nat -> Leq n (plus n (nd 1)) .
transitive_le : transitive Nat Leq .
le_pred_n : n : Nat -> Leq (pred n) n .
monotonic_pred : monotonic Nat Leq pred .
le_S_S_to_le : n : Nat -> m : Nat -> __ : Leq (plus n (nd 1)) (plus m (nd 1)) -> Leq n m .
monotonic_le_plus_r : n : Nat -> monotonic Nat Leq (m : Nat => plus n m) .
monotonic_le_plus_l : m : Nat -> monotonic Nat Leq (n : Nat => plus n m) .
le_plus : n1 : Nat -> n2 : Nat -> m1 : Nat -> m2 : Nat -> __ : Leq n1 n2 -> __1 : Leq m1 m2 -> Leq (plus n1 m1) (plus n2 m2) .
le_plus_n : n : Nat -> m : Nat -> Leq m (plus n m) .
le_plus_a : a : Nat -> n : Nat -> m : Nat -> __ : Leq n m -> Leq n (plus a m) .
le_plus_b : b : Nat -> n : Nat -> m : Nat -> __ : Leq (plus n b) m -> Leq n m .
le_plus_n_r : n : Nat -> m : Nat -> Leq m (plus m n) .
eq_plus_to_le : n : Nat -> m : Nat -> p : Nat -> __ : Eq n (plus m p) -> Leq m n .
le_plus_to_le : a : Nat -> n : Nat -> m : Nat -> __ : Leq (plus a n) (plus a m) -> Leq n m .
le_plus_to_le_r : a : Nat -> n : Nat -> m : Nat -> __ : Leq (plus n a) (plus m a) -> Leq n m .
monotonic_le_times_r : n : Nat -> monotonic Nat Leq (m : Nat => times n m) .
le_times : n1 : Nat -> n2 : Nat -> m1 : Nat -> m2 : Nat -> __ : Leq n1 n2 -> __1 : Leq m1 m2 -> Leq (times n1 m1) (times n2 m2) .
lt_times_n : n : Nat -> m : Nat -> __ : Lt 0 n -> Leq m (times n m) .
le_times_to_le : a : Nat -> n : Nat -> m : Nat -> __ : Lt 0 a -> __1 : Leq (times a n) (times a m) -> Leq n m .
le_plus_minus_m_m : n : Nat -> m : Nat -> Leq n (plus (minus n m) m) .
le_plus_to_minus_r : a : Nat -> b : Nat -> c : Nat -> __ : Leq (plus a b) c -> Leq a (minus c b) .
lt_to_le : x : Nat -> y : Nat -> __ : Lt x y -> Leq x y .
inv_eq_minus_O : x : Nat -> y : Nat -> __ : Eq (minus x y) 0 -> Leq x y .
le_x_times_x : x : Nat -> Leq x (times x x) .
transitive_lt : transitive Nat Lt .
lt_to_le_to_lt : n : Nat -> m : Nat -> p : Nat -> __ : Lt n m -> __1 : Leq m p -> Lt n p .
le_to_lt_to_lt : n : Nat -> m : Nat -> p : Nat -> __ : Leq n m -> __1 : Lt m p -> Lt n p .
lt_S_to_lt : n : Nat -> m : Nat -> __ : Lt (plus n (nd 1)) m -> Lt n m .
ltn_to_ltO : n : Nat -> m : Nat -> __ : Lt n m -> Lt 0 m .
lt_O_S : n : Nat -> Lt 0 (plus n (nd 1)) .
monotonic_lt_plus_r : n : Nat -> monotonic Nat Lt (m : Nat => plus n m) .
monotonic_lt_plus_l : n : Nat -> monotonic Nat Lt (m : Nat => plus m n) .
lt_plus : n : Nat -> m : Nat -> p : Nat -> q : Nat -> __ : Lt n m -> __1 : Lt p q -> Lt (plus n p) (plus m q) .
lt_plus_to_lt_l : n : Nat -> p : Nat -> q : Nat -> __ : Lt (plus p n) (plus q n) -> Lt p q .
lt_plus_to_lt_r : n : Nat -> p : Nat -> q : Nat -> __ : Lt (plus n p) (plus n q) -> Lt p q .
increasing_to_monotonic : f : (__ : Nat -> Nat) -> __ : increasing f -> monotonic Nat Lt f .
monotonic_lt_times_r : c : Nat -> __ : Lt 0 c -> monotonic Nat Lt (t : Nat => times c t) .
monotonic_lt_times_l : c : Nat -> __ : Lt 0 c -> monotonic Nat Lt (t : Nat => times t c) .
lt_to_le_to_lt_times : n : Nat -> m : Nat -> p : Nat -> q : Nat -> __ : Lt n m -> __1 : Leq p q -> __2 : Lt 0 q -> Lt (times n p) (times m q) .
lt_times : n : Nat -> m : Nat -> p : Nat -> q : Nat -> __ : Lt n m -> __1 : Lt p q -> Lt (times n p) (times m q) .
lt_plus_to_minus_r : a : Nat -> b : Nat -> c : Nat -> __ : Lt (plus a b) c -> Lt a (minus c b) .
lt_plus_Sn_r : a : Nat -> x : Nat -> n : Nat -> Lt a (plus (plus a x) (plus n (nd 1))) .
let_clause_16 : n : Nat -> m : Nat -> auto : Lt (plus n (nd 1)) (plus m (nd 1)) -> x32 : Nat -> Eq (plus x32 (nd 1)) (plus x32 (nd 1)) .
lt_S_S_to_lt : n : Nat -> m : Nat -> __ : Lt (plus n (nd 1)) (plus m (nd 1)) -> Lt n m .
not_le_Sn_O : n : Nat -> not (Leq (plus n (nd 1)) 0) .
not_le_to_not_le_S_S : n : Nat -> m : Nat -> __ : not (Leq n m) -> not (Leq (plus n (nd 1)) (plus m (nd 1))) .
not_le_S_S_to_not_le : n : Nat -> m : Nat -> __ : not (Leq (plus n (nd 1)) (plus m (nd 1))) -> not (Leq n m) .
not_le_Sn_n : n : Nat -> not (Leq (plus n (nd 1)) n) .
lt_to_not_le : n : Nat -> m : Nat -> __ : Lt n m -> not (Leq m n) .
not_le_to_lt : n : Nat -> m : Nat -> __ : not (Leq n m) -> Lt m n .
not_lt_to_le : n : Nat -> m : Nat -> __ : not (Lt n m) -> Leq m n .
le_to_not_lt : n : Nat -> m : Nat -> __ : Leq n m -> not (Lt m n) .
decidable_eq_nat : n : Nat -> m : Nat -> decidable (Eq n m) .
decidable_le : n : Nat -> m : Nat -> decidable (Leq n m) .
decidable_lt : n : Nat -> m : Nat -> decidable (Lt n m) .
le_to_or_lt_eq : n : Nat -> m : Nat -> __ : Leq n m -> or (Lt n m) (Eq n m) .
eq_or_gt : n : Nat -> or (Eq 0 n) (Lt 0 n) .
increasing_to_le2 : f : (__ : Nat -> Nat) -> __ : increasing f -> m : Nat -> __1 : Leq (f 0) m -> ex Nat (i : Nat => and (Leq (f i) m) (Lt m (f (plus i (nd 1))))) .
le_inv_plus_l : x : Nat -> y : Nat -> z : Nat -> __ : Leq (plus x y) z -> and (Leq x (minus z y)) (Leq y z) .
lt_inv_plus_l : x : Nat -> y : Nat -> z : Nat -> __ : Lt (plus x y) z -> and (Lt x z) (Lt y (minus z x)) .
lt_or_ge : m : Nat -> n : Nat -> or (Lt m n) (Leq n m) .
le_or_ge : m : Nat -> n : Nat -> or (Leq m n) (Leq n m) .
le_inv_S1 : x : Nat -> y : Nat -> __ : Leq (plus x (nd 1)) y -> ex2 Nat (z : Nat => Leq x z) (z : Nat => Eq y (plus z (nd 1))) .
nat_ind_plus : R : predicate Nat -> __ : R 0 -> __1 : (n : Nat -> __1 : R n -> R (plus n (nd 1))) -> n : Nat -> R n .
lt_O_n_elim : n : Nat -> __ : Lt 0 n -> P : (__1 : Nat -> Prop) -> __1 : (m : Nat -> P (plus m (nd 1))) -> P n .
le_n_O_elim : n : Nat -> __ : Leq n 0 -> P : (__1 : Nat -> Prop) -> __1 : P 0 -> P n .
le_n_Sm_elim : n : Nat -> m : Nat -> __ : Leq n (plus m (nd 1)) -> P : Prop -> __1 : (__1 : Leq (plus n (nd 1)) (plus m (nd 1)) -> P) -> __2 : (__2 : Eq n (plus m (nd 1)) -> P) -> P .
nat_elim1 : n : Nat -> P : (__ : Nat -> Prop) -> __ : (m : Nat -> __ : (p : Nat -> __ : Lt p m -> P p) -> P m) -> P n .
f_ind_aux : A : Set -> f : (__ : A -> Nat) -> P : predicate A -> __ : (n : Nat -> __ : (a : A -> __ : Lt (f a) n -> P a) -> a : A -> __1 : Eq (f a) n -> P a) -> n : Nat -> a : A -> __1 : Eq (f a) n -> P a .
f_ind : A : Set -> f : (__ : A -> Nat) -> P : predicate A -> __ : (n : Nat -> __ : (a : A -> __ : Lt (f a) n -> P a) -> a : A -> __1 : Eq (f a) n -> P a) -> a : A -> P a .
f2_ind_aux : A1 : Set -> A2 : Set -> f : (__ : A1 -> __1 : A2 -> Nat) -> P : relation2 A1 A2 -> __ : (n : Nat -> __ : (a1 : A1 -> a2 : A2 -> __ : Lt (f a1 a2) n -> P a1 a2) -> a1 : A1 -> a2 : A2 -> __1 : Eq (f a1 a2) n -> P a1 a2) -> n : Nat -> a1 : A1 -> a2 : A2 -> __1 : Eq (f a1 a2) n -> P a1 a2 .
f2_ind : A1 : Set -> A2 : Set -> f : (__ : A1 -> __1 : A2 -> Nat) -> P : relation2 A1 A2 -> __ : (n : Nat -> __ : (a1 : A1 -> a2 : A2 -> __ : Lt (f a1 a2) n -> P a1 a2) -> a1 : A1 -> a2 : A2 -> __1 : Eq (f a1 a2) n -> P a1 a2) -> a1 : A1 -> a2 : A2 -> P a1 a2 .
f3_ind_aux : A1 : Set -> A2 : Set -> A3 : Set -> f : (__ : A1 -> __1 : A2 -> __2 : A3 -> Nat) -> P : relation3 A1 A2 A3 -> __ : (n : Nat -> __ : (a1 : A1 -> a2 : A2 -> a3 : A3 -> __ : Lt (f a1 a2 a3) n -> P a1 a2 a3) -> a1 : A1 -> a2 : A2 -> a3 : A3 -> __1 : Eq (f a1 a2 a3) n -> P a1 a2 a3) -> n : Nat -> a1 : A1 -> a2 : A2 -> a3 : A3 -> __1 : Eq (f a1 a2 a3) n -> P a1 a2 a3 .
f3_ind : A1 : Set -> A2 : Set -> A3 : Set -> f : (__ : A1 -> __1 : A2 -> __2 : A3 -> Nat) -> P : relation3 A1 A2 A3 -> __ : (n : Nat -> __ : (a1 : A1 -> a2 : A2 -> a3 : A3 -> __ : Lt (f a1 a2 a3) n -> P a1 a2 a3) -> a1 : A1 -> a2 : A2 -> a3 : A3 -> __1 : Eq (f a1 a2 a3) n -> P a1 a2 a3) -> a1 : A1 -> a2 : A2 -> a3 : A3 -> P a1 a2 a3 .
lt_to_not_eq : n : Nat -> m : Nat -> __ : Lt n m -> not (Eq n m) .
le_n_O_to_eq : n : Nat -> __ : Leq n 0 -> Eq 0 n .
le_to_le_to_eq : n : Nat -> m : Nat -> __ : Leq n m -> __1 : Leq m n -> Eq n m .
increasing_to_injectif : f : (__ : Nat -> Nat) -> __ : increasing f -> injectif Nat Nat f .
minus_Sn_m : m : Nat -> n : Nat -> __ : Leq m n -> Eq (minus (plus n (nd 1)) m) (plus (minus n m) (nd 1)) .
plus_minus : m : Nat -> n : Nat -> p : Nat -> __ : Leq m n -> Eq (plus (minus n m) p) (minus (plus n p) m) .
minus_plus_m_m : n : Nat -> m : Nat -> Eq n (minus (plus n m) m) .
plus_minus_m_m : n : Nat -> m : Nat -> __ : Leq m n -> Eq n (plus (minus n m) m) .
minus_to_plus : n : Nat -> m : Nat -> p : Nat -> __ : Leq m n -> __1 : Eq (minus n m) p -> Eq n (plus m p) .
plus_to_minus : n : Nat -> m : Nat -> p : Nat -> __ : Eq n (plus m p) -> Eq (minus n m) p .
minus_pred_pred : n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : Lt 0 m -> Eq (minus (pred n) (pred m)) (minus n m) .
plus_minus_associative : x : Nat -> y : Nat -> z : Nat -> __ : Leq z y -> Eq (plus x (minus y z)) (minus (plus x y) z) .
le_n_fn : f : (__ : Nat -> Nat) -> __ : increasing f -> n : Nat -> Leq n (f n) .
monotonic_le_minus_l : p : Nat -> q : Nat -> n : Nat -> __ : Leq q p -> Leq (minus q n) (minus p n) .
le_minus_to_plus : n : Nat -> m : Nat -> p : Nat -> __ : Leq (minus n m) p -> Leq n (plus p m) .
le_minus_to_plus_r : a : Nat -> b : Nat -> c : Nat -> __ : Leq c b -> __1 : Leq a (minus b c) -> Leq (plus a c) b .
le_plus_to_minus : n : Nat -> m : Nat -> p : Nat -> __ : Leq n (plus p m) -> Leq (minus n m) p .
monotonic_le_minus_r : p : Nat -> q : Nat -> n : Nat -> __ : Leq q p -> Leq (minus n p) (minus n q) .
increasing_to_le : f : (__ : Nat -> Nat) -> __ : increasing f -> m : Nat -> ex Nat (i : Nat => Leq m (f i)) .
minus_le : x : Nat -> y : Nat -> Leq (minus x y) x .
not_eq_to_le_to_lt : n : Nat -> m : Nat -> __ : not (Eq n m) -> __1 : Leq n m -> Lt n m .
lt_times_n_to_lt_l : n : Nat -> p : Nat -> q : Nat -> __ : Lt (times p n) (times q n) -> Lt p q .
lt_times_n_to_lt_r : n : Nat -> p : Nat -> q : Nat -> __ : Lt (times n p) (times n q) -> Lt p q .
lt_minus_to_plus : a : Nat -> b : Nat -> c : Nat -> __ : Lt (minus a b) c -> Lt a (plus c b) .
lt_minus_to_plus_r : a : Nat -> b : Nat -> c : Nat -> __ : Lt a (minus b c) -> Lt (plus a c) b .
lt_plus_to_minus : n : Nat -> m : Nat -> p : Nat -> __ : Leq m n -> __1 : Lt n (plus p m) -> Lt (minus n m) p .
monotonic_lt_minus_l : p : Nat -> q : Nat -> n : Nat -> __ : Leq n q -> __1 : Lt q p -> Lt (minus q n) (minus p n) .
discr_minus_x_xy : x : Nat -> y : Nat -> __ : Eq x (minus x y) -> or (Eq x 0) (Eq y 0) .
plus_le_0 : x : Nat -> y : Nat -> __ : Leq (plus x y) 0 -> and (Eq x 0) (Eq y 0) .
eq_minus_O : n : Nat -> m : Nat -> __ : Leq n m -> Eq (minus n m) 0 .
distributive_times_minus : distributive Nat times minus .
minus_plus : n : Nat -> m : Nat -> p : Nat -> Eq (minus (minus n m) p) (minus n (plus m p)) .
minus_minus : n : Nat -> m : Nat -> p : Nat -> __ : Leq p m -> __1 : Leq m n -> Eq (plus p (minus n m)) (minus n (minus m p)) .
minus_minus_associative : x : Nat -> y : Nat -> z : Nat -> __ : Leq z y -> __1 : Leq y x -> Eq (minus x (minus y z)) (plus (minus x y) z) .
minus_minus_comm : a : Nat -> b : Nat -> c : Nat -> Eq (minus (minus a b) c) (minus (minus a c) b) .
minus_le_minus_minus_comm : b : Nat -> c : Nat -> a : Nat -> __ : Leq c b -> Eq (minus a (minus b c)) (minus (plus a c) b) .
minus_minus_m_m : m : Nat -> n : Nat -> __ : Leq n m -> Eq (minus m (minus m n)) n .
minus_plus_plus_l : x : Nat -> y : Nat -> h : Nat -> Eq (minus (plus x h) (plus y h)) (minus x y) .
plus_minus_plus_plus_l : z : Nat -> x : Nat -> y : Nat -> h : Nat -> Eq (minus (plus z (plus x h)) (plus y h)) (minus (plus z x) y) .
minus_plus_minus_l : x : Nat -> y : Nat -> z : Nat -> __ : Leq y z -> Eq (minus (plus z x) (minus z y)) (plus x y) .
le_fwd_plus_plus_ge : m1 : Nat -> m2 : Nat -> __ : Leq m2 m1 -> n1 : Nat -> n2 : Nat -> __1 : Leq (plus m1 n1) (plus m2 n2) -> Leq n1 n2 .
eqb : __ : Nat -> __1 : Nat -> bool .
eqb_body : __ : Nat -> __1 : Nat -> bool .
eqb_elim : n : Nat -> m : Nat -> P : (__ : bool -> Prop) -> __ : (__ : Eq n m -> P true) -> __1 : (__1 : not (Eq n m) -> P false) -> P (eqb n m) .
eqb_n_n : n : Nat -> Eq (eqb n n) true .
eqb_true_to_eq : n : Nat -> m : Nat -> __ : Eq (eqb n m) true -> Eq n m .
eqb_false_to_not_eq : n : Nat -> m : Nat -> __ : Eq (eqb n m) false -> not (Eq n m) .
eq_to_eqb_true : n : Nat -> m : Nat -> __ : Eq n m -> Eq (eqb n m) true .
not_eq_to_eqb_false : n : Nat -> m : Nat -> __ : not (Eq n m) -> Eq (eqb n m) false .
leb : __ : Nat -> __1 : Nat -> bool .
leb_body : __ : Nat -> __1 : Nat -> bool .
leb_elim : n : Nat -> m : Nat -> P : (__ : bool -> Prop) -> __ : (__ : Leq n m -> P true) -> __1 : (__1 : not (Leq n m) -> P false) -> P (leb n m) .
leb_true_to_le : n : Nat -> m : Nat -> __ : Eq (leb n m) true -> Leq n m .
leb_false_to_not_le : n : Nat -> m : Nat -> __ : Eq (leb n m) false -> not (Leq n m) .
le_to_leb_true : n : Nat -> m : Nat -> __ : Leq n m -> Eq (leb n m) true .
not_le_to_leb_false : n : Nat -> m : Nat -> __ : not (Leq n m) -> Eq (leb n m) false .
lt_to_leb_false : n : Nat -> m : Nat -> __ : Lt m n -> Eq (leb n m) false .
min : __ : Nat -> __1 : Nat -> Nat .
max : __ : Nat -> __1 : Nat -> Nat .
commutative_min : commutative Nat min .
le_minr : i : Nat -> n : Nat -> m : Nat -> __ : Leq i (min n m) -> Leq i m .
le_minl : i : Nat -> n : Nat -> m : Nat -> __ : Leq i (min n m) -> Leq i n .
to_min : i : Nat -> n : Nat -> m : Nat -> __ : Leq i n -> __1 : Leq i m -> Leq i (min n m) .
commutative_max : commutative Nat max .
le_maxl : i : Nat -> n : Nat -> m : Nat -> __ : Leq (max n m) i -> Leq n i .
le_maxr : i : Nat -> n : Nat -> m : Nat -> __ : Leq (max n m) i -> Leq m i .
to_max : i : Nat -> n : Nat -> m : Nat -> __ : Leq n i -> __1 : Leq m i -> Leq (max n m) i .
p_ord_aux : __ : Nat -> __1 : Nat -> __2 : Nat -> Prod Nat Nat .
p_ord_aux_body : __ : Nat -> __1 : Nat -> __2 : Nat -> Prod Nat Nat .
p_ord : _n : Nat -> _m : Nat -> Prod Nat Nat .
p_ord_aux_0 : n : Nat -> m : Nat -> Eq (p_ord_aux 0 n m) (mk_Prod Nat Nat 0 n) .
p_ord_aux_Strue : n : Nat -> m : Nat -> p : Nat -> q : Nat -> r : Nat -> __ : Eq (mod n m) 0 -> __1 : Eq (p_ord_aux p (div n m) m) (mk_Prod Nat Nat q r) -> Eq (p_ord_aux (plus p (nd 1)) n m) (mk_Prod Nat Nat (plus q (nd 1)) r) .
p_ord_aux_false : p : Nat -> n : Nat -> m : Nat -> a : Nat -> __ : Eq (mod n m) (plus a (nd 1)) -> Eq (p_ord_aux p n m) (mk_Prod Nat Nat 0 n) .
p_ord_degenerate : p : Nat -> n : Nat -> Eq (p_ord_aux p n (nd 1)) (mk_Prod Nat Nat p n) .
p_ord_aux_to_exp : p : Nat -> n : Nat -> m : Nat -> q : Nat -> r : Nat -> __ : Lt 0 m -> __1 : Eq (p_ord_aux p n m) (mk_Prod Nat Nat q r) -> Eq n (times (pow m q) r) .
p_ord_exp : n : Nat -> m : Nat -> i : Nat -> __ : Lt 0 m -> __1 : not (Eq (mod n m) 0) -> p : Nat -> __2 : Leq i p -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n) .
p_ord_aux_to_not_mod_O : p : Nat -> n : Nat -> m : Nat -> q : Nat -> r : Nat -> __ : Lt (nd 1) m -> __1 : Lt 0 n -> __2 : Leq n p -> __3 : Eq (p_ord_aux p n m) (mk_Prod Nat Nat q r) -> not (Eq (mod r m) 0) .
let_clause_1033 : p : Nat -> n : Nat -> q : Nat -> r : Nat -> posp : Lt 0 p -> ndivpr : not (divisible p r) -> Hn : Eq n (times (pow p q) r) -> q0 : Nat -> q1 : Nat -> Hind : Leq (plus q1 (nd 1)) (pow p (plus q1 (nd 1))) -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
p_ord_exp1 : p : Nat -> n : Nat -> q : Nat -> r : Nat -> __ : Lt 0 p -> __1 : not (divisible p r) -> __2 : Eq n (times (pow p q) r) -> Eq (p_ord n p) (mk_Prod Nat Nat q r) .
p_ord_to_exp1 : p : Nat -> n : Nat -> q : Nat -> r : Nat -> __ : Lt (nd 1) p -> __1 : Lt 0 n -> __2 : Eq (p_ord n p) (mk_Prod Nat Nat q r) -> and (not (divisible p r)) (Eq n (times (pow p q) r)) .
let_clause_10331 : p : Nat -> n : Nat -> n1 : Nat -> q : Nat -> p1 : Nat -> p2 : Nat -> qa : Nat -> ra : Nat -> H : Eq (p_ord_aux (plus n1 (nd 1)) (plus n1 (nd 1)) (plus p2 (nd 2))) (mk_Prod Nat Nat qa ra) -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
eq_p_ord_q_O : p : Nat -> n : Nat -> q : Nat -> __ : Eq (p_ord n p) (mk_Prod Nat Nat q 0) -> and (Eq n 0) (Eq q 0) .
p_ord_times : p : Nat -> a : Nat -> b : Nat -> qa : Nat -> ra : Nat -> qb : Nat -> rb : Nat -> __ : prime p -> __1 : Lt 0 a -> __2 : Lt 0 b -> __3 : Eq (p_ord a p) (mk_Prod Nat Nat qa ra) -> __4 : Eq (p_ord b p) (mk_Prod Nat Nat qb rb) -> Eq (p_ord (times a b) p) (mk_Prod Nat Nat (plus qa qb) (times ra rb)) .
fst_p_ord_times : p : Nat -> a : Nat -> b : Nat -> __ : prime p -> __1 : Lt 0 a -> __2 : Lt 0 b -> Eq (fst Nat Nat (p_ord (times a b) p)) (plus (fst Nat Nat (p_ord a p)) (fst Nat Nat (p_ord b p))) .
p_ord_p : p : Nat -> __ : Lt (nd 1) p -> Eq (p_ord p p) (mk_Prod Nat Nat (nd 1) (nd 1)) .
divides_to_p_ord : p : Nat -> a : Nat -> b : Nat -> c : Nat -> d : Nat -> n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : Lt 0 m -> __2 : prime p -> __3 : divisible n m -> __4 : Eq (p_ord n p) (mk_Prod Nat Nat a b) -> __5 : Eq (p_ord m p) (mk_Prod Nat Nat c d) -> and (divisible b d) (Leq a c) .
not_divides_to_p_ord_O : n : Nat -> i : Nat -> __ : not (divisible (nth_prime i) n) -> Eq (p_ord n (nth_prime i)) (mk_Prod Nat Nat 0 n) .
p_ord_O_to_not_divides : n : Nat -> i : Nat -> r : Nat -> __ : Lt 0 n -> __1 : Eq (p_ord n (nth_prime i)) (mk_Prod Nat Nat 0 r) -> not (divisible (nth_prime i) n) .
p_ord_to_not_eq_O : n : Nat -> p : Nat -> q : Nat -> r : Nat -> __ : Lt (nd 1) n -> __1 : Eq (p_ord n (nth_prime p)) (mk_Prod Nat Nat q r) -> not (Eq r 0) .
ord : __ : Nat -> __1 : Nat -> Nat .
ord_rem : __ : Nat -> __1 : Nat -> Nat .
ord_eq : n : Nat -> p : Nat -> Eq (ord n p) (fst Nat Nat (p_ord n p)) .
ord_rem_eq : n : Nat -> p : Nat -> Eq (ord_rem n p) (snd Nat Nat (p_ord n p)) .
divides_to_ord : p : Nat -> n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : Lt 0 m -> __2 : prime p -> __3 : divisible n m -> and (divisible (ord_rem n p) (ord_rem m p)) (Leq (ord n p) (ord m p)) .
divides_to_divides_ord_rem : p : Nat -> n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : Lt 0 m -> __2 : prime p -> __3 : divisible n m -> divisible (ord_rem n p) (ord_rem m p) .
divides_to_le_ord : p : Nat -> n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : Lt 0 m -> __2 : prime p -> __3 : divisible n m -> Leq (ord n p) (ord m p) .
exp_ord : p : Nat -> n : Nat -> __ : Lt (nd 1) p -> __1 : Lt 0 n -> Eq n (times (pow p (ord n p)) (ord_rem n p)) .
divides_ord_rem : p : Nat -> n : Nat -> __ : Lt (nd 1) p -> __1 : Lt 0 n -> divisible (ord_rem n p) n .
lt_O_ord_rem : p : Nat -> n : Nat -> __ : Lt (nd 1) p -> __1 : Lt 0 n -> Lt 0 (ord_rem n p) .
ord_times : p : Nat -> m : Nat -> n : Nat -> __ : Lt 0 m -> __1 : Lt 0 n -> __2 : prime p -> Eq (ord (times m n) p) (plus (ord m p) (ord n p)) .
ord_exp : p : Nat -> m : Nat -> __ : Lt (nd 1) p -> Eq (ord (pow p m) p) m .
not_divides_to_ord_O : p : Nat -> m : Nat -> __ : prime p -> __1 : not (divisible p m) -> Eq (ord m p) 0 .
ord_O_to_not_divides : p : Nat -> m : Nat -> __ : Lt 0 m -> __1 : prime p -> __2 : Eq (ord m p) 0 -> not (divisible p m) .
divides_to_not_ord_O : p : Nat -> m : Nat -> __ : Lt 0 m -> __1 : prime p -> __2 : divisible p m -> not (Eq (ord m p) 0) .
not_ord_O_to_divides : p : Nat -> m : Nat -> __ : Lt 0 m -> __1 : prime p -> __2 : not (Eq (ord m p) 0) -> divisible p m .
not_divides_ord_rem : m : Nat -> p : Nat -> __ : Lt 0 m -> __1 : Lt (nd 1) p -> not (divisible p (ord_rem m p)) .
ord_ord_rem : p : Nat -> q : Nat -> m : Nat -> __ : Lt 0 m -> __1 : prime p -> __2 : prime q -> __3 : Lt q p -> Eq (ord (ord_rem m p) q) (ord m q) .
lt_ord_rem : n : Nat -> m : Nat -> __ : prime n -> __1 : Lt 0 m -> __2 : divisible n m -> Lt (ord_rem m n) m .
p_ord_inv : _p : Nat -> _m : Nat -> _x : Nat -> Nat .
eq_p_ord_inv : p : Nat -> m : Nat -> x : Nat -> Eq (p_ord_inv p m x) (plus (times (ord_rem x p) m) (ord x p)) .
div_p_ord_inv : p : Nat -> m : Nat -> x : Nat -> __ : Lt (ord x p) m -> Eq (div (p_ord_inv p m x) m) (ord_rem x p) .
mod_p_ord_inv : p : Nat -> m : Nat -> x : Nat -> __ : Lt (ord x p) m -> Eq (mod (p_ord_inv p m x) m) (ord x p) .
injn : __ : (__ : Nat -> Nat) -> __1 : Nat -> Prop .
injn_Sn_n : f : (__ : Nat -> Nat) -> n : Nat -> __ : injn f (plus n (nd 1)) -> injn f n .
injective_to_injn : f : (__ : Nat -> Nat) -> n : Nat -> __ : injectif Nat Nat f -> injn f n .
permut : __ : (__ : Nat -> Nat) -> __1 : Nat -> Prop .
permut_O_to_eq_O : h : (__ : Nat -> Nat) -> __ : permut h 0 -> Eq (h 0) 0 .
permut_S_to_permut : f : (__ : Nat -> Nat) -> m : Nat -> __ : permut f (plus m (nd 1)) -> __1 : Eq (f (plus m (nd 1))) (plus m (nd 1)) -> permut f m .
transpose : __ : Nat -> __1 : Nat -> __2 : Nat -> Nat .
transpose_i_j_i : i : Nat -> j : Nat -> Eq (transpose i j i) j .
transpose_i_j_j : i : Nat -> j : Nat -> Eq (transpose i j j) i .
transpose_i_i : i : Nat -> n : Nat -> Eq (transpose i i n) n .
transpose_i_j_j_i : i : Nat -> j : Nat -> n : Nat -> Eq (transpose i j n) (transpose j i n) .
transpose_transpose : i : Nat -> j : Nat -> n : Nat -> Eq (transpose i j (transpose i j n)) n .
injective_transpose : i : Nat -> j : Nat -> injectif Nat Nat (transpose i j) .
permut_transpose : i : Nat -> j : Nat -> n : Nat -> __ : Leq i n -> __1 : Leq j n -> permut (transpose i j) n .
permut_fg : f : (__ : Nat -> Nat) -> g : (__ : Nat -> Nat) -> n : Nat -> __ : permut f n -> __1 : permut g n -> permut (m : Nat => f (g m)) n .
permut_transpose_l : f : (__ : Nat -> Nat) -> m : Nat -> i : Nat -> j : Nat -> __ : Leq i m -> __1 : Leq j m -> __2 : permut f m -> permut (n : Nat => transpose i j (f n)) m .
permut_transpose_r : f : (__ : Nat -> Nat) -> m : Nat -> i : Nat -> j : Nat -> __ : Leq i m -> __1 : Leq j m -> __2 : permut f m -> permut (n : Nat => f (transpose i j n)) m .
eq_transpose : i : Nat -> j : Nat -> k : Nat -> n : Nat -> __ : not (Eq j i) -> __1 : not (Eq i k) -> __2 : not (Eq j k) -> Eq (transpose i j n) (transpose i k (transpose k j (transpose i k n))) .
permut_S_to_permut_transpose : f : (__ : Nat -> Nat) -> m : Nat -> __ : permut f (plus m (nd 1)) -> permut (n : Nat => transpose (f (plus m (nd 1))) (plus m (nd 1)) (f n)) m .
bijn : __ : (__ : Nat -> Nat) -> __1 : Nat -> Prop .
eq_to_bijn : f : (__ : Nat -> Nat) -> g : (__ : Nat -> Nat) -> n : Nat -> __ : (i : Nat -> __ : Leq i n -> Eq (f i) (g i)) -> __1 : bijn f n -> bijn g n .
let_clause_1075 : f : (__ : Nat -> Nat) -> n : Nat -> bijf : bijn f (plus n (nd 1)) -> fS : Eq (f (plus n (nd 1))) (plus n (nd 1)) -> i : Nat -> lein : Leq i n -> a : Nat -> _clearme : and (Leq a (plus n (nd 1))) (Eq (f a) i) -> lean : Leq a (plus n (nd 1)) -> fa : Eq (f a) i -> Hc : Eq a (plus n (nd 1)) -> Eq i a .
bijn_Sn_n : f : (__ : Nat -> Nat) -> n : Nat -> __ : bijn f (plus n (nd 1)) -> __1 : Eq (f (plus n (nd 1))) (plus n (nd 1)) -> bijn f n .
bijn_n_Sn : f : (__ : Nat -> Nat) -> n : Nat -> __ : bijn f n -> __1 : Eq (f (plus n (nd 1))) (plus n (nd 1)) -> bijn f (plus n (nd 1)) .
bijn_fg : f : (__ : Nat -> Nat) -> g : (__ : Nat -> Nat) -> n : Nat -> __ : bijn f n -> __1 : bijn g n -> bijn (p : Nat => f (g p)) n .
bijn_transpose : n : Nat -> i : Nat -> j : Nat -> __ : Leq i n -> __1 : Leq j n -> bijn (transpose i j) n .
bijn_transpose_r : f : (__ : Nat -> Nat) -> n : Nat -> i : Nat -> j : Nat -> __ : Leq i n -> __1 : Leq j n -> __2 : bijn f n -> bijn (p : Nat => f (transpose i j p)) n .
bijn_transpose_l : f : (__ : Nat -> Nat) -> n : Nat -> i : Nat -> j : Nat -> __ : Leq i n -> __1 : Leq j n -> __2 : bijn f n -> bijn (p : Nat => transpose i j (f p)) n .
permut_to_bijn : n : Nat -> f : (__ : Nat -> Nat) -> __ : permut f n -> bijn f n .
invert_permut : __ : Nat -> __1 : (__1 : Nat -> Nat) -> __2 : Nat -> Nat .
invert_permut_body : __ : Nat -> __1 : (__1 : Nat -> Nat) -> __2 : Nat -> Nat .
invert_permut_f : f : (__ : Nat -> Nat) -> n : Nat -> m : Nat -> __ : Leq m n -> __1 : injn f n -> Eq (invert_permut n f (f m)) m .
let_clause_1063 : f : (__ : Nat -> Nat) -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> lein : Leq i n -> lejn : Leq j n -> a : Nat -> _clearme : and (Leq a n) (Eq (f a) i) -> lean : Leq a n -> fa : Eq (f a) i -> b : Nat -> _clearme0 : and (Leq b n) (Eq (f b) j) -> lebn : Leq b n -> fb : Eq (f b) j -> __ : (i0 : Nat -> __ : Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> auto : Eq a b -> Eq (f a) j .
let_clause_1068 : f : (__ : Nat -> Nat) -> n : Nat -> permf : permut f n -> i : Nat -> j : Nat -> lein : Leq i n -> lejn : Leq j n -> a : Nat -> _clearme : and (Leq a n) (Eq (f a) i) -> lean : Leq a n -> fa : Eq (f a) i -> b : Nat -> _clearme0 : and (Leq b n) (Eq (f b) j) -> lebn : Leq b n -> fb : Eq (f b) j -> __ : (i0 : Nat -> __ : Leq i0 n -> Leq (f i0) n) -> injf : injn f n -> auto : Eq a b -> Eq (f a) i .
injective_invert_permut : f : (__ : Nat -> Nat) -> n : Nat -> __ : permut f n -> injn (invert_permut n f) n .
permut_invert_permut : f : (__ : Nat -> Nat) -> n : Nat -> __ : permut f n -> permut (invert_permut n f) n .
f_invert_permut : f : (__ : Nat -> Nat) -> n : Nat -> m : Nat -> __ : Leq m n -> __1 : permut f n -> Eq (f (invert_permut n f m)) m .
permut_n_to_eq_n : h : (__ : Nat -> Nat) -> n : Nat -> __ : permut h n -> __1 : (m : Nat -> __1 : Lt m n -> Eq (h m) m) -> Eq (h n) n .
permut_n_to_le : h : (__ : Nat -> Nat) -> k : Nat -> n : Nat -> __ : Leq k n -> __1 : permut h n -> __2 : (m : Nat -> __2 : Lt m k -> Eq (h m) m) -> j : Nat -> __3 : Leq k j -> __4 : Leq j n -> Leq k (h j) .
decidable_mem_nat : n : Nat -> l : list Nat -> decidable (mem Nat n l) .
length_unique_le : n : Nat -> l : list Nat -> __ : unique Nat l -> __1 : (x : Nat -> __1 : mem Nat x l -> Lt x n) -> Leq (length Nat l) n .
eq_length_to_mem : n : Nat -> l : list Nat -> __ : Eq (length Nat l) (plus n (nd 1)) -> __1 : unique Nat l -> __2 : (x : Nat -> __2 : mem Nat x l -> Leq x n) -> mem Nat n l .
eq_length_to_mem_all : n : Nat -> l : list Nat -> __ : Eq (length Nat l) n -> __1 : unique Nat l -> __2 : (x : Nat -> __2 : mem Nat x l -> Lt x n) -> i : Nat -> __3 : Lt i n -> mem Nat i l .
lt_length_to_not_mem : n : Nat -> l : list Nat -> __ : unique Nat l -> __1 : (x : Nat -> __1 : mem Nat x l -> Lt x n) -> __2 : Lt (length Nat l) n -> ex Nat (i : Nat => and (Lt i n) (not (mem Nat i l))) .
divisible : _n : Nat -> _m : Nat -> Prop .
quotient : n : Nat -> m : Nat -> q : Nat -> __ : Eq m (times n q) -> divisible n m .
match_divides : _n : Nat -> _m : Nat -> return_sort : Sort -> return_type : (z : divisible _n _m -> return_sort) -> case_quotient : (q : Nat -> __ : Eq _m (times _n q) -> return_type (quotient _n _m q __)) -> z : divisible _n _m -> return_type z .
filter_divides : _n : Nat -> _m : Nat -> return_sort : Sort -> return_type : (z : divisible _n _m -> return_sort) -> return : (z : divisible _n _m -> return_type z) -> z : divisible _n _m -> return_type z .
divides_ind : _n : Nat -> _m : Nat -> Q_ : (_x_1192 : divisible _n _m -> Prop) -> _H_quotient : (q : Nat -> x_1193 : Eq _m (times _n q) -> Q_ (quotient _n _m q x_1193)) -> x_1192 : divisible _n _m -> Q_ x_1192 .
divides_ind_body : _n : Nat -> _m : Nat -> Q_ : (_x_1192 : divisible _n _m -> Prop) -> _H_quotient : (q : Nat -> x_1193 : Eq _m (times _n q) -> Q_ (quotient _n _m q x_1193)) -> x_1192 : divisible _n _m -> Q_ x_1192 .
divides_inv_ind : x1 : Nat -> x2 : Nat -> Hterm : divisible x1 x2 -> P : (_z2006 : divisible x1 x2 -> Prop) -> _H1 : (q : Nat -> x_1193 : Eq x2 (times x1 q) -> _z2007 : Eq Hterm (quotient x1 x2 q x_1193) -> P (quotient x1 x2 q x_1193)) -> P Hterm .
reflexive_divides : reflexive Nat divisible .
divides_to_div_mod_spec : n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : divisible n m -> div_mod_spec m n (div m n) 0 .
div_mod_spec_to_divides : n : Nat -> m : Nat -> q : Nat -> __ : div_mod_spec m n q 0 -> divisible n m .
divides_to_mod_O : n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : divisible n m -> Eq (mod m n) 0 .
mod_O_to_divides : n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : Eq (mod m n) 0 -> divisible n m .
divides_n_O : n : Nat -> divisible n 0 .
divides_n_n : n : Nat -> divisible n n .
divides_SO_n : n : Nat -> divisible (nd 1) n .
divides_plus : n : Nat -> p : Nat -> q : Nat -> __ : divisible n p -> __1 : divisible n q -> divisible n (plus p q) .
divides_minus : n : Nat -> p : Nat -> q : Nat -> __ : divisible n p -> __1 : divisible n q -> divisible n (minus p q) .
divides_times : n : Nat -> m : Nat -> p : Nat -> q : Nat -> __ : divisible n p -> __1 : divisible m q -> divisible (times n m) (times p q) .
transitive_divides : transitive Nat divisible .
eq_mod_to_divides : n : Nat -> m : Nat -> q : Nat -> __ : Lt 0 q -> __1 : Eq (mod n q) (mod m q) -> divisible q (minus n m) .
let_clause_1531 : n : Nat -> m : Nat -> posm : Lt 0 m -> _clearme : divisible n m -> d : Nat -> eqm : Eq m (times n 0) -> Eq m 0 .
let_clause_15311 : n : Nat -> m : Nat -> posm : Lt 0 m -> _clearme : divisible n m -> d : Nat -> p : Nat -> eqm : Eq m (times n (plus p (nd 1))) -> Eq m (plus n (times n p)) .
divides_to_le : n : Nat -> m : Nat -> __ : Lt 0 m -> __1 : divisible n m -> Leq n m .
antisymmetric_divides : n : Nat -> m : Nat -> __ : divisible n m -> __1 : divisible m n -> Eq n m .
divides_to_lt_O : n : Nat -> m : Nat -> __ : Lt 0 m -> __1 : divisible n m -> Lt 0 n .
or_div_mod1 : n : Nat -> q : Nat -> __ : Lt 0 q -> or (and (divisible q (plus n (nd 1))) (Eq (plus n (nd 1)) (times (plus (div n q) (nd 1)) q))) (and (not (divisible q (plus n (nd 1)))) (Eq (plus n (nd 1)) (plus (times (div n q) q) (plus (mod n q) (nd 1))))) .
let_clause_1532 : n : Nat -> m : Nat -> divnm : divisible n m -> H : Eq 0 n -> d : Nat -> auto : Eq m (times 0 d) -> Eq m 0 .
let_clause_1559 : n : Nat -> m : Nat -> divnm : divisible n m -> H : Eq 0 n -> d : Nat -> auto : Eq m (times 0 d) -> Eq m n .
let_clause_1560 : n : Nat -> m : Nat -> divnm : divisible n m -> H : Eq 0 n -> d : Nat -> auto : Eq m (times 0 d) -> Eq n 0 .
divides_to_div : n : Nat -> m : Nat -> __ : divisible n m -> Eq (times (div m n) n) m .
divides_div : d : Nat -> n : Nat -> __ : divisible d n -> divisible (div n d) n .
div_div : n : Nat -> d : Nat -> __ : Lt 0 n -> __1 : divisible d n -> Eq (div n (div n d)) d .
times_div : a : Nat -> b : Nat -> c : Nat -> __ : Lt 0 b -> __1 : divisible c b -> Eq (times a (div b c)) (div (times a b) c) .
plus_div : n : Nat -> m : Nat -> d : Nat -> __ : Lt 0 d -> __1 : divisible d n -> __2 : divisible d m -> Eq (div (plus n m) d) (plus (div n d) (div m d)) .
dividesb : __ : Nat -> __1 : Nat -> bool .
dividesb_true_to_divides : n : Nat -> m : Nat -> __ : Eq (dividesb n m) true -> divisible n m .
dividesb_false_to_not_divides : n : Nat -> m : Nat -> __ : Eq (dividesb n m) false -> not (divisible n m) .
decidable_divides : n : Nat -> m : Nat -> decidable (divisible n m) .
divides_to_dividesb_true : n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : divisible n m -> Eq (dividesb n m) true .
let_clause_15321 : n : Nat -> m : Nat -> posn : Lt 0 m -> eqn0 : Eq 0 n -> _clearme : divisible 0 m -> q : Nat -> eqm : Eq m (times 0 q) -> Eq m 0 .
let_clause_15591 : n : Nat -> m : Nat -> posn : Lt 0 m -> eqn0 : Eq 0 n -> _clearme : divisible 0 m -> q : Nat -> eqm : Eq m (times 0 q) -> Eq m n .
let_clause_15601 : n : Nat -> m : Nat -> posn : Lt 0 m -> eqn0 : Eq 0 n -> _clearme : divisible 0 m -> q : Nat -> eqm : Eq m (times 0 q) -> Eq n 0 .
divides_to_dividesb_true1 : n : Nat -> m : Nat -> __ : Lt 0 m -> __1 : divisible n m -> Eq (dividesb n m) true .
not_divides_to_dividesb_false : n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : not (divisible n m) -> Eq (dividesb n m) false .
dividesb_div_true : d : Nat -> n : Nat -> __ : Lt 0 n -> __1 : Eq (dividesb d n) true -> Eq (dividesb (div n d) n) true .
let_clause_1573 : n : Nat -> m : Nat -> posn : Lt 0 n -> _clearme : divisible m n -> d : Nat -> auto : Eq 0 m -> auto' : Eq n (times m d) -> Eq n m .
let_clause_1585 : n : Nat -> m : Nat -> posn : Lt 0 n -> _clearme : divisible m n -> d : Nat -> auto : Eq 0 m -> auto' : Eq n (times m d) -> Eq 0 n .
dividesb_true_to_lt_O : n : Nat -> m : Nat -> __ : Lt 0 n -> __1 : divisible m n -> Lt 0 m .
prime : __ : Nat -> Prop .
not_prime_O : not (prime 0) .
not_prime_SO : not (prime (nd 1)) .
prime_to_lt_O : p : Nat -> __ : prime p -> Lt 0 p .
prime_to_lt_SO : p : Nat -> __ : prime p -> Lt (nd 1) p .
smallest_factor : __ : Nat -> Nat .
smallest_factor_to_min : n : Nat -> __ : Lt (nd 1) n -> Eq (smallest_factor n) (min n (nd 2) (m : Nat => eqb (mod n m) 0)) .
example1 : Eq (smallest_factor (nd 3)) (nd 3) .
example2 : Eq (smallest_factor (nd 4)) (nd 2) .
example3 : Eq (smallest_factor (nd 7)) (nd 7) .
le_SO_smallest_factor : n : Nat -> __ : Leq n (nd 1) -> Eq (smallest_factor n) n .
lt_SO_smallest_factor : n : Nat -> __ : Lt (nd 1) n -> Lt (nd 1) (smallest_factor n) .
lt_O_smallest_factor : n : Nat -> __ : Lt 0 n -> Lt 0 (smallest_factor n) .
divides_smallest_factor_n : n : Nat -> __ : Lt 0 n -> divisible (smallest_factor n) n .
le_smallest_factor_n : n : Nat -> Leq (smallest_factor n) n .
lt_smallest_factor_to_not_divides : n : Nat -> i : Nat -> __ : Lt (nd 1) n -> __1 : Lt (nd 1) i -> __2 : Lt i (smallest_factor n) -> not (divisible i n) .
prime_smallest_factor_n : n : Nat -> __ : Lt (nd 1) n -> prime (smallest_factor n) .
prime_to_smallest_factor : n : Nat -> __ : prime n -> Eq (smallest_factor n) n .
smallest_factor_to_prime : n : Nat -> __ : Lt (nd 1) n -> __1 : Eq (smallest_factor n) n -> prime n .
primeb : _n : Nat -> bool .
example4 : Eq (primeb (nd 3)) true .
example5 : Eq (primeb (nd 6)) false .
example6 : Eq (primeb (nn 1 (nd 1))) true .
example7 : Eq (primeb (nn 1 (nd 7))) true .
primeb_true_to_prime : n : Nat -> __ : Eq (primeb n) true -> prime n .
primeb_false_to_not_prime : n : Nat -> __ : Eq (primeb n) false -> not (prime n) .
decidable_prime : n : Nat -> decidable (prime n) .
prime_to_primeb_true : n : Nat -> __ : prime n -> Eq (primeb n) true .
not_prime_to_primeb_false : n : Nat -> __ : not (prime n) -> Eq (primeb n) false .
divides_fact : n : Nat -> i : Nat -> __ : Lt 0 i -> __1 : Leq i n -> divisible i (factorial n) .
mod_S_fact : n : Nat -> i : Nat -> __ : Lt (nd 1) i -> __1 : Leq i n -> Eq (mod (plus (factorial n) (nd 1)) i) (nd 1) .
not_divides_S_fact : n : Nat -> i : Nat -> __ : Lt (nd 1) i -> __1 : Leq i n -> not (divisible i (plus (factorial n) (nd 1))) .
smallest_factor_fact : n : Nat -> Lt n (smallest_factor (plus (factorial n) (nd 1))) .
ex_prime : n : Nat -> __ : Leq (nd 1) n -> ex Nat (m : Nat => and (and (Lt n m) (Leq m (plus (factorial n) (nd 1)))) (prime m)) .
nth_prime : __ : Nat -> Nat .
nth_prime_body : __ : Nat -> Nat .
let_previous_prime : __ : Nat -> p : Nat -> Nat .
let_upper_bound : __ : Nat -> p : Nat -> Nat .
let_previous_prime1 : n : Nat -> Nat .
let_upper_bound1 : n : Nat -> Nat .
nth_primeS : n : Nat -> Eq (nth_prime (plus n (nd 1))) (min (let_upper_bound1 n) (plus (let_previous_prime1 n) (nd 1)) primeb) .
example11 : Eq (nth_prime (nd 2)) (nd 5) .
example12 : Eq (nth_prime (nd 3)) (nd 7) .
example13 : Eq (nth_prime (nd 4)) (nn 1 (nd 1)) .
let_previous_prime2 : n : Nat -> m : Nat -> Nat .
let_upper_bound2 : n : Nat -> m : Nat -> Nat .
let_previous_prime3 : n : Nat -> m : Nat -> x : Nat -> Nat .
let_upper_bound3 : n : Nat -> m : Nat -> x : Nat -> Nat .
let_previous_prime4 : n : Nat -> m : Nat -> Nat .
let_upper_bound4 : n : Nat -> m : Nat -> Nat .
prime_nth_prime : n : Nat -> prime (nth_prime n) .
increasing_nth_prime : n : Nat -> Lt (nth_prime n) (nth_prime (plus n (nd 1))) .
lt_SO_nth_prime_n : n : Nat -> Lt (nd 1) (nth_prime n) .
lt_O_nth_prime_n : n : Nat -> Lt 0 (nth_prime n) .
lt_n_nth_prime_n : n : Nat -> Lt n (nth_prime n) .
let_previous_prime5 : n : Nat -> m : Nat -> ltml : Lt (nth_prime n) m -> Nat .
let_upper_bound5 : n : Nat -> m : Nat -> ltml : Lt (nth_prime n) m -> Nat .
let_previous_prime6 : n : Nat -> m : Nat -> ltml : Lt (nth_prime n) m -> x : Nat -> Nat .
let_upper_bound6 : n : Nat -> m : Nat -> ltml : Lt (nth_prime n) m -> x : Nat -> Nat .
let_previous_prime7 : n : Nat -> m : Nat -> ltml : Lt (nth_prime n) m -> Nat .
let_upper_bound7 : n : Nat -> m : Nat -> ltml : Lt (nth_prime n) m -> Nat .
lt_nth_prime_to_not_prime : n : Nat -> m : Nat -> __ : Lt (nth_prime n) m -> __1 : Lt m (nth_prime (plus n (nd 1))) -> not (prime m) .
prime_to_nth_prime : p : Nat -> __ : prime p -> ex Nat (i : Nat => Eq (nth_prime i) p) .
plusA : Aop Nat 0 .
plusAC : ACop Nat 0 .
timesA : Aop Nat (nd 1) .
timesAC : ACop Nat (nd 1) .
natD : Dop Nat 0 .
sigma_const : n : Nat -> Eq (bigop n (i : Nat => true) Nat 0 plus (i : Nat => nd 1)) n .
let_clause_1033 : n : Nat -> p1 : (__ : Nat -> bool) -> p2 : (__ : Nat -> bool) -> g1 : (__ : Nat -> Nat) -> g2 : (__ : Nat -> Nat) -> n1 : Nat -> Hind : (__ : (i : Nat -> __ : Lt i n1 -> __1 : Eq (p1 i) true -> Eq (p2 i) true) -> __1 : (i : Nat -> __1 : Lt i n1 -> __2 : Eq (p1 i) true -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (i : Nat => p1 i) Nat 0 plus (i : Nat => g1 i)) (bigop n1 (i : Nat => p2 i) Nat 0 plus (i : Nat => g2 i))) -> H1 : (i : Nat -> __ : Lt i (plus n1 (nd 1)) -> __1 : Eq (p1 i) true -> Eq (p2 i) true) -> H2 : (i : Nat -> __ : Lt i (plus n1 (nd 1)) -> __1 : Eq (p1 i) true -> Leq (g1 i) (g2 i)) -> Hp2 : Eq (p2 n1) true -> Hp1 : Eq (p1 n1) true -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
le_sigma : n : Nat -> p1 : (__ : Nat -> bool) -> p2 : (__ : Nat -> bool) -> g1 : (__ : Nat -> Nat) -> g2 : (__ : Nat -> Nat) -> __ : (i : Nat -> __ : Lt i n -> __1 : Eq (p1 i) true -> Eq (p2 i) true) -> __1 : (i : Nat -> __1 : Lt i n -> __2 : Eq (p1 i) true -> Leq (g1 i) (g2 i)) -> Leq (bigop n (i : Nat => p1 i) Nat 0 plus (i : Nat => g1 i)) (bigop n (i : Nat => p2 i) Nat 0 plus (i : Nat => g2 i)) .
lt_sigma_p : n : Nat -> p1 : (__ : Nat -> bool) -> p2 : (__ : Nat -> bool) -> g1 : (__ : Nat -> Nat) -> g2 : (__ : Nat -> Nat) -> __ : (i : Nat -> __ : Lt i n -> __1 : Eq (p1 i) true -> Eq (p2 i) true) -> __1 : (i : Nat -> __1 : Lt i n -> __2 : Eq (p1 i) true -> Leq (g1 i) (g2 i)) -> __2 : ex Nat (i : Nat => and (Lt i n) (or (and (Eq (p1 i) true) (Lt (g1 i) (g2 i))) (and (and (Eq (p1 i) false) (Eq (p2 i) true)) (Lt 0 (g2 i))))) -> Lt (bigop n (i : Nat => p1 i) Nat 0 plus (i : Nat => g1 i)) (bigop n (i : Nat => p2 i) Nat 0 plus (i : Nat => g2 i)) .
let_clause_10331 : n : Nat -> p : (__ : Nat -> bool) -> g1 : (__ : Nat -> Nat) -> g2 : (__ : Nat -> Nat) -> n1 : Nat -> Hind : (__ : (i : Nat -> __ : Lt i n1 -> __1 : Eq (p i) true -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (i : Nat => p i) Nat (nd 1) times (i : Nat => g1 i)) (bigop n1 (i : Nat => p i) Nat (nd 1) times (i : Nat => g2 i))) -> Hle : (i : Nat -> __ : Lt i (plus n1 (nd 1)) -> __1 : Eq (p i) true -> Leq (g1 i) (g2 i)) -> Hcase : Eq (p n1) true -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
le_pi : n : Nat -> p : (__ : Nat -> bool) -> g1 : (__ : Nat -> Nat) -> g2 : (__ : Nat -> Nat) -> __ : (i : Nat -> __ : Lt i n -> __1 : Eq (p i) true -> Leq (g1 i) (g2 i)) -> Leq (bigop n (i : Nat => p i) Nat (nd 1) times (i : Nat => g1 i)) (bigop n (i : Nat => p i) Nat (nd 1) times (i : Nat => g2 i)) .
exp_sigma : n : Nat -> a : Nat -> p : (__ : Nat -> bool) -> Eq (bigop n (i : Nat => p i) Nat (nd 1) times (i : Nat => a)) (pow a (bigop n (i : Nat => p i) Nat 0 plus (i : Nat => nd 1))) .
times_pi : n : Nat -> p : (__ : Nat -> bool) -> f : (__ : Nat -> Nat) -> g : (__ : Nat -> Nat) -> Eq (bigop n (i : Nat => p i) Nat (nd 1) times (i : Nat => times (f i) (g i))) (times (bigop n (i : Nat => p i) Nat (nd 1) times (i : Nat => f i)) (bigop n (i : Nat => p i) Nat (nd 1) times (i : Nat => g i))) .
pi_1 : n : Nat -> p : (__ : Nat -> bool) -> Eq (bigop n (i : Nat => p i) Nat (nd 1) times (i : Nat => nd 1)) (nd 1) .
exp_pi : n : Nat -> m : Nat -> p : (__ : Nat -> bool) -> f : (__ : Nat -> Nat) -> Eq (bigop n (i : Nat => p i) Nat (nd 1) times (i : Nat => pow (f i) m)) (pow (bigop n (i : Nat => p i) Nat (nd 1) times (i : Nat => f i)) m) .
exp_sigma_l : n : Nat -> a : Nat -> p : (__ : Nat -> bool) -> f : (__ : Nat -> Nat) -> Eq (bigop n (i : Nat => p i) Nat (nd 1) times (i : Nat => pow a (f i))) (pow a (bigop n (i : Nat => p i) Nat 0 plus (i : Nat => f i))) .
exp_pi_l : n : Nat -> a : Nat -> f : (__ : Nat -> Nat) -> Eq (times (pow a n) (bigop n (i : Nat => true) Nat (nd 1) times (i : Nat => f i))) (bigop n (i : Nat => true) Nat (nd 1) times (i : Nat => times a (f i))) .
exp_pi_bc : a : Nat -> b : Nat -> c : Nat -> f : (__ : Nat -> Nat) -> Eq (times (pow a (minus c b)) (bigop (minus c b) (i : Nat => (i0 : Nat => true) (plus i b)) Nat (nd 1) times (i : Nat => (i0 : Nat => f i0) (plus i b)))) (bigop (minus c b) (i : Nat => (i0 : Nat => true) (plus i b)) Nat (nd 1) times (i : Nat => (i0 : Nat => times a (f i0)) (plus i b))) .
sqrt : _n : Nat -> Nat .
sqrt_def : n : Nat -> Eq (sqrt n) (max (plus n (nd 1)) (x : Nat => leb (times x x) n)) .
eq_sqrt : n : Nat -> Eq (sqrt (times n n)) n .
le_sqrt_to_le_times_l : m : Nat -> n : Nat -> __ : Leq n (sqrt m) -> Leq (times n n) m .
lt_sqrt_to_lt_times_l : m : Nat -> n : Nat -> __ : Lt n (sqrt m) -> Lt (times n n) m .
lt_sqrt_to_lt_times_r : m : Nat -> n : Nat -> __ : Lt (sqrt m) n -> Lt m (times n n) .
leq_sqrt_n : n : Nat -> Leq (times (sqrt n) (sqrt n)) n .
le_sqrt_n : n : Nat -> Leq (sqrt n) n .
lt_sqrt_n : n : Nat -> __ : Lt (nd 1) n -> Lt (sqrt n) n .
lt_sqrt : n : Nat -> Lt n (pow (plus (sqrt n) (nd 1)) (nd 2)) .
le_sqrt_n1 : n : Nat -> Leq (minus n (times (nd 2) (sqrt n))) (pow (sqrt n) (nd 2)) .
le_sqrt_nl : n : Nat -> m : Nat -> __ : Lt (nd 3) n -> Leq (times (times m (pred m)) n) (pow (sqrt (times (pow m (nd 2)) n)) (nd 2)) .
le_sqrt_log : n : Nat -> b : Nat -> __ : Lt (nd 2) b -> Leq (log b n) (sqrt n) .
le_sqrt_log_n : n : Nat -> b : Nat -> __ : Lt (nd 2) b -> Leq (times (sqrt n) (log b n)) n .
le_square_exp : n : Nat -> __ : Lt (nd 3) n -> Leq (pow n (nd 2)) (pow (nd 2) n) .
let_clause_1033 : n : Nat -> le_n : Leq (pow (nd 2) (nd 4)) n -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
le_log2_sqrt : n : Nat -> __ : Leq (pow (nd 2) (nd 4)) n -> Leq (log (nd 2) n) (sqrt n) .
square_S : a : Nat -> Eq (pow (plus a (nd 1)) (nd 2)) (plus (plus (pow a (nd 2)) (times (nd 2) a)) (nd 1)) .
let_clause_10331 : n : Nat -> lt4n : Lt (nd 5) n -> m : Nat -> le4m : Leq (nd 6) m -> Hind : Leq (pow (plus m (nd 1)) (nd 2)) (pow (nd 2) m) -> a : Nat -> lea : Leq (nd 6) a -> Hinda : Leq (plus (times (nd 2) (plus a (nd 1))) (nd 1)) (pow (nd 2) a) -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
le_squareS_exp : n : Nat -> __ : Lt (nd 5) n -> Leq (pow (plus n (nd 1)) (nd 2)) (pow (nd 2) n) .
let_clause_10332 : n : Nat -> le_n : Leq (pow (nd 2) (nd 6)) n -> x2515 : Nat -> x2516 : Nat -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516)) .
lt_log2_sqrt : n : Nat -> __ : Leq (pow (nd 2) (nd 6)) n -> Lt (log (nd 2) n) (sqrt n) .
monotonic_sqrt : monotonic Nat Leq sqrt .
